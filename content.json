[{"title":"STM32(Cortex-M4) 时钟配置","date":"2017-09-22T03:18:51.462Z","path":"2017/09/22/stm32-clock/","text":"前言1学习、总结，交流，进步！ 测试环境为Keil 5.20 &amp;&amp; (STM32F405ZET6 || STM32F407ZET6)。外部晶振频率不同，就需要配置时钟以此获知各外设的时钟频率，比如常用的定时器。 原创，转载请注明出处。 时钟树介绍介绍时钟配置之前，安利一个ST的针对于STM32提供的一个软件，STM32CubeMX，常用来进行硬件选型，外设资源分配以及可以进行配置生成基于HAL库的配置程序等功能。当然了，大多数都应该知道这个软件，就不赘述了。其中还有一个功能是提供时钟树的配置，配置后可以直观的看到各个部分/外设的工作时钟，个人觉得挺好的，如下图所示： 这里简单介绍上图(从左到右)：红色外框：从这里选中HSE(外部时钟)，并配置外部时钟的频率。(我这里外部晶振使用的是8MHz，内部时钟部分自行参考)黑色外框：M N P参数，常说的倍频部分。黄色外框：通过设置倍频系数，得到的系统频率。(系统最大频率，请参考计数文档)绿色外框：AHB 分频得到HCLK频率。蓝色外框：下面两个框分频后得到APB1和APB2的时钟。最后面是到各个外设的工作频率。 时钟配置时钟配置其实最主要的就是设置倍频和分频的系数，很简单。这里就这几个系数在什么位置说明一下，请打开system_stm32f4xx.c文件。这里使用的是F4的库，STM32F4xx_DSP_StdPeriph_Lib_V1.8.0，芯片f405/f407，所以在Keil中定义了STM32F40_41xxx(根据此宏确定该系数的唯一位置)，下面程序是截取system_stm32f4xx.c文件，需要修改的位置在程序中有说明，请仔细查看这一部分。首先我们需要修改外部时钟的频率，改为外部使用的晶振频率，是在系统文件stm32f4xx.h中：1234567891011121314151617/** * @brief In the following line adjust the value of External High Speed oscillator (HSE) used in your application Tip: To avoid modifying this file each time you need to use different HSE, you can define the HSE value in your toolchain compiler preprocessor. */#if defined(STM32F40_41xxx) || defined(STM32F427_437xx) || defined(STM32F429_439xx) || defined(STM32F401xx) || \\ defined(STM32F410xx) || defined(STM32F411xE) || defined(STM32F469_479xx) #if !defined (HSE_VALUE) /* 修改外部时钟频率，默认25MHz，25000000，我使用8MHz， */ #define HSE_VALUE ((uint32_t)8000000) /*!&lt; Value of the External oscillator in Hz */ #endif /* HSE_VALUE */#elif defined (STM32F412xG) || defined(STM32F413_423xx) || defined(STM32F446xx) #if !defined (HSE_VALUE) #define HSE_VALUE ((uint32_t)8000000) /*!&lt; Value of the External oscillator in Hz */ #endif /* HSE_VALUE */#endif /* STM32F40_41xxx || STM32F427_437xx || STM32F429_439xx || STM32F401xx || STM32F411xE || STM32F469_479xx */ 然后倍频的系数设置：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/************************* PLL Parameters *************************************/#if defined(STM32F40_41xxx) || defined(STM32F427_437xx) || defined(STM32F429_439xx) || defined(STM32F401xx) || defined(STM32F469_479xx) /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLL_M) * PLL_N */ #define PLL_M 8//25 /******** 修改PLL_M系数，源文件中默认为25，因为ST默认使用25MHz晶振。修改为8分频是根据前面时钟树的配置进行修改 ********/#elif defined(STM32F412xG) || defined (STM32F446xx) #define PLL_M 8#elif defined (STM32F410xx) || defined (STM32F411xE) #if defined(USE_HSE_BYPASS) #define PLL_M 8 #else /* !USE_HSE_BYPASS */ #define PLL_M 16 #endif /* USE_HSE_BYPASS */#else#endif /* STM32F40_41xxx || STM32F427_437xx || STM32F429_439xx || STM32F401xx || STM32F469_479xx *//* USB OTG FS, SDIO and RNG Clock = PLL_VCO / PLLQ */#define PLL_Q 7#if defined(STM32F446xx)/* PLL division factor for I2S, SAI, SYSTEM and SPDIF: Clock = PLL_VCO / PLLR */#define PLL_R 7#elif defined(STM32F412xG)#define PLL_R 2#else#endif /* STM32F446xx */#if defined(STM32F427_437xx) || defined(STM32F429_439xx) || defined(STM32F446xx) || defined(STM32F469_479xx)#define PLL_N 360/* SYSCLK = PLL_VCO / PLL_P */#define PLL_P 2#endif /* STM32F427_437x || STM32F429_439xx || STM32F446xx || STM32F469_479xx */#if defined (STM32F40_41xxx)#define PLL_N 336 /******** 修改PLL_N，根据前面时钟树的配置进行修改 ********//* SYSCLK = PLL_VCO / PLL_P */#define PLL_P 2 /******** 修改PLL_P，根据前面时钟树的配置进行修改 ********/#endif /* STM32F40_41xxx */#if defined(STM32F401xx)#define PLL_N 336/* SYSCLK = PLL_VCO / PLL_P */#define PLL_P 4#endif /* STM32F401xx */#if defined(STM32F410xx) || defined(STM32F411xE) || defined(STM32F412xG)#define PLL_N 400/* SYSCLK = PLL_VCO / PLL_P */#define PLL_P 4#endif /* STM32F410xx || STM32F411xE *//******************************************************************************/ 下面程序截取自system_stm32f4xx.c文件中设置时钟的函数，时钟初始化设置。分频部分的系数设置：12345678910111213141516171819202122232425262728293031323334353637383940414243static void SetSysClock(void)&#123;#if defined(STM32F40_41xxx) || defined(STM32F427_437xx) || defined(STM32F429_439xx) || defined(STM32F401xx) || defined(STM32F412xG) || defined(STM32F446xx)|| defined(STM32F469_479xx)/******************************************************************************//* PLL (clocked by HSE) used as System clock source *//******************************************************************************/ __IO uint32_t StartUpCounter = 0, HSEStatus = 0; /* Enable HSE */ RCC-&gt;CR |= ((uint32_t)RCC_CR_HSEON); /* Wait till HSE is ready and if Time out is reached exit */ do &#123; HSEStatus = RCC-&gt;CR &amp; RCC_CR_HSERDY; StartUpCounter++; &#125; while((HSEStatus == 0) &amp;&amp; (StartUpCounter != HSE_STARTUP_TIMEOUT)); if ((RCC-&gt;CR &amp; RCC_CR_HSERDY) != RESET) &#123; HSEStatus = (uint32_t)0x01; &#125; else &#123; HSEStatus = (uint32_t)0x00; &#125; if (HSEStatus == (uint32_t)0x01) &#123; /* Select regulator voltage output Scale 1 mode */ RCC-&gt;APB1ENR |= RCC_APB1ENR_PWREN; PWR-&gt;CR |= PWR_CR_VOS; /* HCLK = SYSCLK / 1*/ RCC-&gt;CFGR |= RCC_CFGR_HPRE_DIV1; /******** AHB 分频，通过对sysclk分频后得到HCLK时钟频率，此处1分频 ********/#if defined(STM32F40_41xxx) || defined(STM32F427_437xx) || defined(STM32F429_439xx) || defined(STM32F412xG) || defined(STM32F446xx) || defined(STM32F469_479xx) /* PCLK2 = HCLK / 2*/ RCC-&gt;CFGR |= RCC_CFGR_PPRE2_DIV8;//RCC_CFGR_PPRE2_DIV2; /******** APB2 分频，通过对前面HCLK分频后得到，PCLK2时钟频率，默认2分频，根据前面时钟树配置为8分频 ********/ /* PCLK1 = HCLK / 4*/ RCC-&gt;CFGR |= RCC_CFGR_PPRE1_DIV4;//RCC_CFGR_PPRE1_DIV4; /******** APB1 分频，通过对前面HCLK分频后得到，PCLK1时钟频率，默认4分频，根据前面时钟树配置为4分频不变 ********/#endif /* STM32F40_41xxx || STM32F427_437x || STM32F429_439xx || STM32F412xG || STM32F446xx || STM32F469_479xx */ 其实通过这样简单几步设置，时钟配置就完成了，各个部分的时钟如前面图片所示。接下来我们通过库函数来获取HCLK，PCLK1和PCLK2的时钟频率。在函数库文件stm32f4xx_rcc.c中提供函数RCC_GetClocksFreq来获取SYSCLK，HCLK，PCLK1和PCLK2的时钟频率：123RCC_ClocksTypeDef rcc_clock; /* 结构体，成员就是4个时钟频率 */RCC_GetClocksFreq(&amp;rcc_clock); 通过串口将结构体成员的值打印出来，就可以很直观的知道各个外设的时钟频率了。其实在函数库文件stm32f4xx_rcc.c中还有设置AHB，APB1和APB2分频系数的函数，这里不做介绍，具体请参考此文件。 结束语时钟配置的过程很简单，我觉得更重要的是熟悉STM32的时钟结构，各个外设使用的是哪个部分的时钟，这样才能在使用的时候少犯错，尤其是定时器，时钟错了，定时就错了，尴尬。F1的系统时钟初始化这部分，跟F4差别挺大的，可能不适用，大致参考一下。","tags":[{"name":"STM32","slug":"STM32","permalink":"https:/jungleeee.github.io.git/tags/STM32/"}]},{"title":"STM32(Cortex-M4) 定时器-DMA WS2812-GRB-LED","date":"2017-09-19T06:45:34.788Z","path":"2017/09/19/stm32-timer-dma/","text":"前言1学习、总结，交流，进步！ 测试环境为Keil 5.20 &amp;&amp; (STM32F405ZET6 || STM32F407ZET6)。采用来控制WS2812-GRB全彩LED，主要是因为其控制时序要求较高，频率快。如果使用中断的方式，处理时序容易出错。 原创，转载请注明出处。 关于WS28212说明WS2812实际可以认为有红、蓝、绿三个LED组成，通过控制其中的灯是否点亮以及点亮时的光照强度的不同组合，实现更多色彩的显示(三原色原理)。因此控制WS2812色彩显示的时候需要控制“三个LED”，总共包含24bit的控制数据，红、蓝、绿各8bit；由于8bit数据表示范围为0-255，所以光照强度可以分成256各等级。24bit数据格式如下图所示： 前面提到0-255表示该原色的亮度，因此就需要改变8bit数据每一位的0/1状态，其0码和1码的格式如下图所示： 从图中可以看到0码/1码是在固定周期中高低电平时间不同的组合。整个周期时长1.25us左右，允许误差600ns。虽然STM32指令周期很短了，但是使用中断方式的话，明显不是很好。 Timer-DMA请注意以下几点：1、关于STM32定时器色的DMA功能，需要注意的时TIM9-TMI14(100pin封装)是没有DMA功能的，所以在做硬件设计时需要注意。2、请注意定时器所挂载的时钟频率，保证定时器配置后输出频率正确：TIM2、3、4、5、6、7、12、13、14使用APB1时钟；TIM1、8、9使用APB2时钟。3、关于如何配置定时器输出PWM波，此处不介绍。 接下来开始程序搭建。我选择了TIM5-Channel2输出控制时序，TIM5的时钟挂载在APB1上面，所以打开該时钟，以及不要要忘记打开IO的映射功能。123RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM5, ENABLE); /* open tim5 clock *//* 其它此处不列出 */GPIO_PinAFConfig(GOIOA,GPIO_PinSource1,GPIO_AF_TIM5); /* GPIOA-pin1 AF tim5-channel2 */ 打开定时器时钟后，需要配置PWM的输出频率。上面介绍到WS2812每一位数据的周期是1.25us，也就是说需要设置PWM输出周期为1.25us。在我的STM32时钟配置中，APB1的时钟输出为84MHz，所以有以下配置：123TIM_TimeBaseInitStructure.TIM_Prescaler = 0; /* 1/84 = 0.0119047619047619us */TIM_TimeBaseInitStructure.TIM_Period = 105; /* 0.0119047619047619 * 105 = 1.254us //71 34 */TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up; 这里设置了定时器不分频，及其计数频率为(84 / (0+1))MHz，一次计数时间为0.01190476…us，所以继续配置计数重装载值为105，实现1.254us的PWM输出周期。那么可以继续得到，71和34两个数值分别表示高低电平的时长。PWM输出方式配置为小于捕获/比较寄存器的值时，输出高电平：123TIM_OCInitStructure.TIM_Pulse = 0;TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1;TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High; /* 小于TIM_Pluse的值时输出高电平 */ 输出连续的0/1的状态，也就是在定时器当前周期计数溢出开始下一个周期计数时，修改比较寄存器的值，改变输出高电平的时长，达到输出0/1的目的。也就是说需要在定时器计数溢出更新时触发DMA事件，通过DMA将新的比较寄存器的值写入到寄存器中。DMA配置如下：123456789101112DMA_InitStructure.DMA_Channel = DMA_Channel_6;DMA_InitStructure.DMA_PeripheralBaseAddr = (uint32_t)&amp;TIM5-&gt;CCR2; /* Peripheral address */DMA_InitStructure.DMA_Memory0BaseAddr = NULL; /* Memory address */DMA_InitStructure.DMA_DIR = DMA_DIR_MemoryToPeripheral; /* DMA dir Memory To Peripheral */DMA_InitStructure.DMA_BufferSize = 1; /* length */DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable; /* Peripheral address not add */DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable; /* Memory address add */DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Word; /* Peripheral data length */DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Word; /* Memory data length */DMA_InitStructure.DMA_Mode = DMA_Mode_Normal; /* normal mode */DMA_InitStructure.DMA_Priority = DMA_Priority_Medium; /* DMA Priority */DMA_Init(DMA1_Stream6, &amp;DMA_InitStructure); DMA数据长度初始化设置没有关系，在数据发送时设置即可。这里设置了外设数据字长为一个字(32bit)，需要注意一下。定时器2和定时器5的捕获/比较寄存器是32bit的，而其他是16bit的，如下图所示，更多请参考技术文档，希望大家注意。 关于DMA数据流和通道选择，请参考下图，更多信息请参考STM32技术文档。因为需要触发DMA的是溢出更新事件，所以选择的是TIM5_UP。 接下来选择DMA的触发源，打开定时器和DMA功能：123456789101112TIM_SelectCCDMA(TIM5, ENABLE); /* 配置为发生更新事件时产生DMA请求，详情请参考TIMx-CR2 寄存器 */TIM_DMACmd(TIM5, TIM_DMA_Update, ENABLE); /* 使能TIMx的更新DMA请求，详情请参考TIMx-DIER 寄存器 */TIM_UpdateRequestConfig(TIM5, TIM_UpdateSource_Regular); /* 使能URS位，只在定时器上溢/下溢时产生中断/DMA请求，详情请参考TIMx-CR1 寄存器 */TIM_UpdateDisableConfig(TIM5, DISABLE); /* 详情请参考TIMx-CR1 寄存器 */DMA_Cmd(DMA1_Stream6, ENABLE);DMA_ITConfig(DMA1_Stream6, DMA_IT_TC, DISABLE);DMA_ClearITPendingBit(DMA1_Stream6, DMA_IT_TCIF6);TIM_Cmd(TIM5, ENABLE);TIM_ITConfig(TIM5, TIM_IT_Update, DISABLE);TIM_ClearFlag(TIM5, TIM_FLAG_Update); 定时器的配置大致这样，有其他问题请参考其他。 ws2812 控制这里就简单说明以下。通过前面分析，知道了通过写入捕获比较寄存器的值(34/71)，实现0/1的位输出，所以定义：123456 |g7|g6|g5|g4|g3|g2|g1|g0|r7|r6|r5|r4|r3|r2|r1|r0|b7|b6|b5|b4|b3|b2|b1|b0|unsigned char green[] = &#123;71,71,71,71,71,71,71,71,34,34,34,34,34,34,34,34,34,34,34,34,34,34,34,34,0&#125;; /* 11111111 00000000 00000000 */unsigned char red[] = &#123;34,34,34,34,34,34,34,34,71,71,71,71,71,71,71,71,34,34,34,34,34,34,34,34,0&#125;;unsigned char blue[] = &#123;34,34,34,34,34,34,34,34,34,34,34,34,34,34,34,34,71,71,71,71,71,71,71,71,0&#125;;unsigned char white[] = &#123;71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,0&#125;;unsigned char reset[50] = &#123;0&#125;; /* 复位需要长达50us的低电平时间 */ 在实际控制中，只需要配置好需要的颜色，将数组的起始地址设置为DMA的内存地址后启动DMA即可。如果上一次操作完成后关闭了定时器，请记得打开。有一点需要注意以下，上面每个数组实际上都定义了25个成员，最后一个都为0。是因为DMA传输完成后，捕获/比较寄存器的值是最后一次传输的值，34/71，如果没有关闭定时器，那么定时器就会一直输出0码/1码(对于WS2812)，也就是WS2812的状态会变成全部熄灭(全0)/全亮(全1)，导致出错，所以DMA最后一次发送0到捕获/比较寄存器中，使得PWM输出一直为低。WS2812技术文档有说到输出低电平50us会复位，但在实际使用中发现，前一刻的状态并不会被改变，也就是说全输出为低电平时能够保持之前状态，经测试可行。上面提到了两种方式：1、传输完成后，在DMA传输完成中断函数中关闭定时器，下一次传输前打开定时器。！！！！！此方式未测试！！！！！！ 2、DMA传输最后一次数据到捕获/比较寄存器的值设置为0，通过输出低电平保持前一刻的状态。实测可行。 参考程序：https://github.com/jungleeee/Cortex-M/tree/master/Cortex-M4/timer-dma 结束语工作当中有这个LED的功能需求，在开发过程中还是遇到了一些问题，认认真真的看了TIMx-DMA着一块，还是有一些需要注意的东西。比如一开始选择DMA通道的时候，因为PWM输出时TIM5的通道2，就选择了DMA通道TIM5_CH2，实际应该是TIM5_UP，导致出错。还有一点是DMA发送完成后，传输完成位，会置位，如果配置了传输完成中断，可以在中断中清除此位，没有配置中断的话，必须在下一次发送前清除此位，否则下一次传输会失败。","tags":[{"name":"STM32","slug":"STM32","permalink":"https:/jungleeee.github.io.git/tags/STM32/"}]},{"title":"vim 常用插件配置","date":"2017-09-14T07:26:29.268Z","path":"2017/09/14/vim-plug-in/","text":"前言12学习、总结，交流，进步！插件与脚本使得VIM强大，毋庸置疑！ 全程参考: 所需及所获:像使用IDE一样vim其余参考将会在文中相关部分列出。文中内容如有错误，请指正！原创，转载请注明出处！ ReadyVIM的安转请自行进行。版本最好在7.5以上。请检查用户目录下是否存在: .vim/文件夹和.vimrc用户配置文件，可以使用命令 ls -l ~ 查看。.vim/文件夹用于存放后续所有插件。.vimrc用于配置VIM功能，包括基本语法、插件配置以及部分脚本等。如果没有请自行创建。 基本配置可以直接添加到.vimrc文件中: 123456789101112131415161718192021222324252627&quot; General set &quot; .vimrc 文件保存后自动生效 autocmd! bufwritepost .vimrc source % &quot; linux &quot;let g:mapleader=&quot;;&quot; &quot; vim 前缀键设置，默认为: \\ set autowrite &quot; auto save file set nobackup &quot; 不产生临时文件 set noswapfile &quot; 不产生临时文件 &quot;set t_ti= t_te= &quot; 退出VIM时，将当前屏幕内容显示到终端屏幕上 &quot; 不使用鼠标，方向键。实测插入模式中还是可以使用 &quot;set mouse-=a &quot;map &lt;Left&gt; &lt;Nop&gt; &quot;map &lt;Right&gt; &lt;Nop&gt; &quot;map &lt;Up&gt; &lt;Nop&gt; &quot;map &lt;Down&gt; &lt;Nop&gt; &quot; 普通模式时使用ctrl+h/j/k/l 实现多文件编辑时窗口切换 nnoremap &lt;C-j&gt; &lt;C-W&gt;j nnoremap &lt;C-k&gt; &lt;C-W&gt;k nnoremap &lt;C-h&gt; &lt;C-W&gt;h nnoremap &lt;C-l&gt; &lt;C-W&gt;l &quot; 插入模式时使用ctrl+h/j/k/l 实现光标移动 inoremap &lt;C-j&gt; &lt;Down&gt; inoremap &lt;C-k&gt; &lt;Up&gt; inoremap &lt;C-h&gt; &lt;Left&gt; inoremap &lt;C-l&gt; &lt;Right&gt; 插件管理Vundle是一个行之有效的插件，接管.vim/文件夹，为每一个插件指定唯一目录。更清晰、明了。Vundle会接管.vim/文件夹下的所有目录，所以先清空。在通过命令安装Vundle: 1git clone https://github.com/VundleVim/Vundle.vim.git ~/.vim/bundle/Vundle.vim 然后在.vimrc中增加配置: 123456789101112131415161718192021222324252627282930313233343536373839&quot; vundle set filetype off set rtp+=~/.vim/bundle/Vundle.vim call vundle#begin() Plugin &apos;VundleVim/Vundle.vim&apos; Plugin &apos;altercation/vim-colors-solarized&apos; Plugin &apos;tomasr/molokai&apos; &quot;Pluglin &apos;vim-scripts/phd&apos; &quot;Plugin &apos;Lokaltog/vim-powerline&apos; Plugin &apos;vim-airline/vim-airline&apos; Plugin &apos;vim-airline/vim-airline-themes&apos; &quot;Plugin &apos;nathanaelkane/vim-indent-guides&apos; Plugin &apos;Yggdroot/indentLine&apos; Plugin &apos;derekwyatt/vim-fswitch&apos; Plugin &apos;majutsushi/tagbar&apos; Plugin &apos;vim-scripts/indexer.tar.gz&apos; Plugin &apos;vim-scripts/DfrankUtil&apos; Plugin &apos;vim-scripts/vimprj&apos; Plugin &apos;easymotion/vim-easymotion&apos; &quot;Plugin &apos;mileszs/ack.vim&apos; Plugin &apos;dyng/ctrlsf.vim&apos; Plugin &apos;terryma/vim-multiple-cursors&apos; Plugin &apos;Yggdroot/LeaderF&apos; Plugin &apos;scrooloose/nerdcommenter&apos; Plugin &apos;ShowTrailingWhiteSpace&apos; Plugin &apos;SirVer/ultisnips&apos; &quot;Plugin &apos;honza/vim-snippets&apos; Plugin &apos;Valloric/YouCompleteMe&apos; Plugin &apos;scrooloose/nerdtree&apos; Plugin &apos;fholgado/minibufexpl.vim&apos; Plugin &apos;Tabular&apos; &quot; automatic alignment Plugin &apos;plasticboy/vim-markdown&apos; &quot; Plugin &apos;iamcco/markdown-preview.vim&apos; &quot;Plugin &apos;iamcco/mathjax-support-for-mkdp&apos; call vundle#end() filetype indent on &quot; different file smart indent filetype plugin on &quot; load the corrrsponding plug-in for different f filetype plugin indent on &quot; open antomatic completion vundle管理的插件必须位于call vundle#begin() 和 call vundle#end()之间，其中每项 1Plugin &apos;VundleVim/Vundle.vim&apos; 对应一个插件，后续如有新的插件，只需要追加到该列表中。安装新插件时需要在Github上找到插件地址，追加到列表中保存.vimrc文件，然后进入到VIM命令模式，执行: 1PluginInstall 便可以通过vundle自动安装插件。 需要卸载插件时，需要在.vimrc文件中注释该插件或者删除，保存.vimrc文件后，在命令模式执行: 1PluginClean 即可删除该插件。关于插件更新，直接在命令模式下，执行: 1PluginUpdate 即可更新整个插件列表。 关于插件: 多数插件在Github上都有不同的下载源，优先选取该插件的作者的下载源。 UI Theme界面优化，主题配置: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&quot; Vim-UI set &#123; &quot; theme &#123;很实用的两款:solarized、molokai set background=dark let g:solarized_termtrans=256 colorscheme solarized &quot;colorscheme molokai &quot;set guifont = &quot; set default font &quot; &#125; &quot; code fold &#123;代码折叠的方式，method: manual, indent, expr, syntax, diff, marker &quot;set foldenable &quot; 启动VIM时，折叠 set nofoldenable &quot; 启动VIM时，不折叠 set foldmethod=syntax &quot; 基于语法进行折叠 &quot;set foldmarker=&#123;,&#125; &quot; &#125; &quot; search &#123;搜索 set incsearch &quot; set hlsearch &quot; 搜索结果高亮 set ignorecase &quot; 忽略大小写 &quot; &#125; syntax enable &quot; 语法高亮 syntax on &quot; set expandtab &quot; 使用空格键代替TAB键 set tabstop=4 &quot; TAB键的宽度 set shiftwidth=4 &quot; TAB键4个空格键 &quot;set softtabstop=4 &quot; 把4个空格键自动识别为疑个TAB键 set laststatus=2 &quot; 总是显示状态栏 set ruler &quot; 打开状态标尺 set number &quot; 显示行号 set nowrap &quot; set autoindent &quot; 自动缩进 set cursorline &quot; 高亮当前行 &quot;set cursorcolumn &quot; 高亮当前列 set showmatch &quot; highlighting the matching brack &quot;set gcr=a:block-blinon0 &quot; 禁止光标闪烁 &quot;set guioptions-=l &quot; ban on the scroll bar dispaly &quot;set guioptions-=L &quot;set guioptions-=r &quot;set guioptions-=R &quot;set guioptions-=m &quot; ban on the menu bar dispaly &quot;set guioptions-=M&quot; &#125; 主题通过前面插件列表下载了solarized、molokai两款主题，可以通过注释其中一款而是用另一款。在实际使用中molokai可以直接使用，而主题solarized使用时，背景配色异常，最后通过以下方式正常使用（安装后能够正常使用的请忽略）。 选取终端菜单栏中Edit(编辑)栏，最后一项Profile Preference，在弹出界面框中选中color项，如下图所示: 代码折叠文件代码量大时，可能会对分析代码产生干扰，或者通过折叠函数调用与定义之间的代码，可以更加直观的理解函数功能。VIM自身支持多种折叠：手动折叠(manual)、基于缩进进行折叠(indent)、基于语义进行折叠(syntax)、未更改文本构成折叠等等。其中indent、syntax较为适合编程。此段摘抄 所需及所获:像使用IDE一样使用vim 4.3节。 操作: za: 打开或关闭当前折叠；zM: 关闭多有折叠；zR: 打开多有折叠。 其他VIM基本配置项很多，本人并没有进行太多设置，具体设置项的作用或者功能，请参考其他.vimrc文件，或者对该项Search，基本上都能够得到解释，在此不过多赘述。将会在文末贴上部分其他作者的.vimrc文件，以供参考。 插件详细状态栏12345set laststatus=2 &quot; 总是显示状态栏&quot;Plugin &apos;Lokaltog/vim-powerline&apos;Plugin &apos;vim-airline/vim-airline&apos;Plugin &apos;vim-airline/vim-airline-themes&apos; vim-powerline 和 vim-airline 都是状态栏美化插件，选用其一，注释另外一个。vim-airline-theme 提供 vim-airline 的主题，在其路径 vim-airline-theme/doc/ 下文件 airline-themes.txt 有对于可使用的主题的介绍。 状态栏配置，在.vimrc文件中添加以下内容: 12&quot; set powerline theme stylelet g:Powerline_colorscheme=&apos;solarized256&apos; 当选择vim-powerline作为状态栏主题时，添加上述内容；选择vim-airline时，添加以下内容: 12&quot; set airling theme stylelet g:airline_theme=&apos;powerlineish&apos; 可视化缩进12Plugin &apos;Yggdroot/indentLine&apos;&quot;Plugin &apos;nathanaelkane/vim-indent-guides&apos; 很多代码规范中建议代码嵌套最多不能超过3层，但难免有更多层出现。vim-indent-guides 插件提供可视化缩进，将相同缩进的代码关联起来，vim-indent-guides通过识别制表符来绘制缩进连接线。在.vimrc文件中添加如下配置: 1234&quot; set indent guideslet g:indent_guides_enable_on_vim_startup=1 &quot; 打开VIM时跟随启动let g:indent_guides_start_level=2 &quot; 从第二层开始可视化缩进let g:indent_guides_guide_sizw=1 &quot; 色块宽度 本人配置完成后使用，发现色块宽度占了4个空格，原因未查。 另外一个插件indentLine ，在显示可视化缩进时，只有一根细线，甚和我意。推荐一哈。后面还有一款他写的插件LeaderF，提供文件搜索功能，后面在介绍。indentLine基本上可以不用配置，但提供几个可选用配置项。 12345&quot; set indentLine&quot;let g:indentLine_enable = 1 &quot; 默认就是开启的&quot;let g:indentLine_char = &apos;┆&apos; &apos;│&apos; &apos;⎸&apos; &apos;▏&apos; &apos;¦&apos; &quot; 配置可视化缩进时的显示符号，选其一&quot;let g:indentLine_color_term = 239 &quot; 参看作者的解释&quot;map &lt;C-i&gt; :IndentLineToggle&lt;CR&gt; &quot; 映射快捷键用来开启/关闭可是话缩进 文件切换1Plugin &apos;derekwyatt/vim-fswitch&apos; vim-fswitch 用来实现在源文件和头文件中快速切换，但需要保证文件名相同，比如main.c和main.h。需要在.vimrc文件中添加: 12&quot; *.c** &amp; *.h, fast switchnmap &lt;M-t&gt; :FSHere&lt;CR&gt; &quot; 切换文件 *.c/cpp/.. &amp; *.h 我在这里使用了Alt+t组合键，M代表Alt键。除掉苹果键盘，Alt键就在大拇指下，个人觉得这个键，使用很方便。插播一下Alt键说明: 1我选择这个键只有一个原因，就是觉得的不用起来，好浪费。但是实际使用起来bug有比较多，所以。。。我选择了将就。 标签系统代码中的变量、宏、结构、枚举、类、函数、对象等等这些统称为标识符，每个标识符的定义、所在文件的行位置、所在文件的路径等信息就是标签（tag)。此段摘抄 所需及所获:像使用IDE一样使用vim 4.6节。 Exuberant Ctags就是一款经典的用于生成代码标签信息的工具，支持数十种语言。请在终端中执行命令安装。安装完成后，在代码目录中执行: 1ctags -R 将会在当前目录下生成tag文件，包含了当前目录下所有文件的标识符集合。 标签除了可以很直观展示当前文件中的各种信息，还能提供强大的导航和补全功能，接下来将会一一介绍。 在生成tag文件后，可以通过插件 tagbar 把从当前代码文件中提取出的所有标识符放在一个侧边子窗口中，并且能够按语法规则将标识符进行归类。tagbar安装完成后在.vimrc文件中添加如下配置: 123456789101112131415161718192021222324252627282930313233343536373839&quot; set tagbarmap &lt;F8&gt; :TagbarToggle&lt;CR&gt; &quot; 通过快捷键F8实现tagbar打开/关闭let tagbar_left=1 &quot; 设置tagbar子窗口的位置出现在主编辑的左边let tagbar_width=32 &quot; 设置窗口宽度let g:tagbar_compact=1 &quot; 子窗口不显示冗余帮助信息let g:tagbar_sort=0 &quot; 设置默认排序方式为在文中出现的位置let g:tagbar_type_cpp = &#123; &quot; 设置对哪些代码标识符生成标签 \\&apos;kinds&apos; : [ \\ &apos;c:classes:0:0&apos;, \\ &apos;d:macros:0:0&apos;, \\ &apos;e:enumerators:0:0&apos;, \\ &apos;f:functions:0:0&apos;, \\ &apos;g:enumeration:0:0&apos;, \\ &apos;l:local:0:0&apos;, \\ &apos;m:members:0:0&apos;, \\ &apos;n:namespaces:0:0&apos;, \\ &apos;p:functions_prototypes:0:0&apos;, \\ &apos;s:structs:0:0&apos;, \\ &apos;t:typedefs:0:0&apos;, \\ &apos;u:unions:0:0&apos;, \\ &apos;v:global:0:0&apos;, \\ &apos;x:wxternal:0:0&apos; \\ ], \\ &apos;sro&apos; : &apos;::&apos;, \\ &apos;kind2scope&apos; : &#123; \\ &apos;g&apos; : &apos;enum&apos;, \\ &apos;n&apos; : &apos;namespaces&apos;, \\ &apos;c&apos; : &apos;class&apos;, \\ &apos;s&apos; : &apos;struct&apos;, \\ &apos;u&apos; : &apos;union&apos; \\ &#125;, \\ &apos;scope2kind&apos; : &#123; \\ &apos;enum&apos; : &apos;g&apos;, \\ &apos;namespace&apos; : &apos;n&apos;, \\ &apos;class&apos; : &apos;c&apos;, \\ &apos;struct&apos; : &apos;s&apos;, \\ &apos;union&apos; : &apos;u&apos; \\ &#125; \\ &#125; 进入之前生成tag文件的目录下，打开某一源文件后，通过快捷键F8 打开tagbar子窗口，可以通过快捷键ctrl+w+w快速切换子窗口，类似alt+tab的功能，或者使用前面定义的ctrl+h/i/j/k在normal模式下进行窗口切换，进入到tagbar窗口中。 在标识符列表中选中对应标识符后即可跳转至源码中对应位置;在源码中停顿几秒，tagbar将高亮对应标识符。tagbar有两种排序方式，一是按标签字母先后顺序；一是按标签在源码中出现的先后顺序。此段摘抄 所需及所获:像使用IDE一样使用vim 4.7节。 注释掉let g:tagbar_sort=0，将会使用字母顺序排序。 开发时代码不停在变更，如果每次都需要手动执行命令生成新的标签文件，太麻烦。通过引入插件 indexer 实现自动生成标签。并引入。indexer 依赖 DfrankUtil、vimprj 两个插件，请一并安装。 此段摘抄所需及所获:像使用IDE一样使用vim 4.7节。 123Plugin &apos;vim-scripts/indexer.tar.gz&apos;Plugin &apos;vim-scripts/DfrankUtil&apos;Plugin &apos;vim-scripts/vimprj&apos; 并在.vimrc文件中添加: 1234&quot; 设置插件 indexer 调用 ctags 的参数&quot; 默认 --c++-kinds=+p+l，重新设置为 --c++-kinds=+p+l+x+c+d+e+f+g+m+n+s+t+u+v&quot; 默认 --fields=+iaS 不满足 YCM 要求，需改为 --fields=+iaSllet g:indexer_ctagsCommandLineOptions=&quot;--c++-kinds=+p+l+x+c+d+e+f+g+m+n+s+t+u+v --fields=+iaSl --extra=+q&quot; 另外，indexer 还有个自己的配置文件，用于设定各个工程的根目录路径，配置文件位于~/.indexer_files，内容格式为: 12[project_name]/project/code 方括号内为自动生成的标签文件名字，一般更工程一样。路径为工程的代码目录，不要包含构建目录，文档目录等，以免产生非代码文件的标签信息。当打开以上目录任何代码文件时，插件indexer便对整个目录创建标签文件，当代码有更新，文件保存时，indexer将自动调用ctags更新标签文件。indexer生成的标签文件以方括号内的名字命名，位于目录: ~/.indexer_files_tags/ 下，并自动引入Vim中。此处3段摘抄 所需及所获:像使用IDE一样使用vim 4.7节。 声明/定义跳转主要两类导航: 基于标签的跳转和基于语义的跳转。 既然Vim可以引入标签，说明Vim能识别标签。虽然标签文件中并无行号，但已经有标签所在文件以及标签所在行的完整内容，Vim只需切换至对应文件，再在文件内做内容查找即可找到对应行。换言之，只要有对应的标签文件，Vim就能根据标签跳转至标签定义处。 在前述已生成标签文件的项目目录中打开任意文件，将光标定位到某一函数名或变量上，键入快捷键g]，Vim将罗列处该函数或变量名所有的标签候选列表，按需要键入编号后按Enter键即可跳转进入。 基于语义的跳转是在后面介绍补全时的一款插件YCM的功能。此处直接给出快捷键设置，在.vimrc文件中添加配置: 123&quot;nnoremap &lt;M-=&gt; :YcmCompleter GoToDefinition&lt;CR&gt; &quot; jump to define&quot;nnoremap &lt;M-=&gt; :YcmCompleter GoToDeclaration&lt;CR&gt; &quot; jump to declarationnnoremap &lt;M-=&gt; :YcmCompleter GoToDefinitionElseDeclaration&lt;CR&gt; &quot; jump to define or declaration YCM提供这三个快捷键定义，意思很明了，可以根据自己情况进行配置，当然需要配置不同的快捷键。 但是个人感觉，这两个插件的跳转功能都不够好用。 写到这儿，有点不想写了。很多东西在我参考的文章中都很详细，很多地方都是摘抄过来的，所以后续我回直接贴出我所介绍的插件在原文章中的章节位置，然后主要介绍我所遇到的一些小问题和解决办法，以及我的快捷键配置，提供十分有限的参考价值，谢谢。 快速移动vim-easymotion 更多请参考 所需及所获:像使用IDE一样使用vim 8.3节。 .vimrc文件配置如下: 1Plugin &apos;easymotion/vim-easymotion&apos; 12&quot; set easymotionlet g:EasyMotion_leader_key=&apos;f&apos; 设置启用easymotion的前缀键&lt;Leader&gt;为f，在normal模式下，双击f键后输入需要跳转到的位置的字母，然后根据快速跳转的字符，快速定位到目标位置。 内容查找更多请参考 所需及所获:像使用IDE一样使用vim 4.8节。 ctrlsf.vim 后端调用ack一定记得安装。.vimrc文件中添加配置如下: 1Plugin &apos;dyng/ctrlsf.vim&apos; 123&quot; set ctrlsf let g:ctrlsf_ackprg=&apos;ack&apos; &quot; set default nnoremap &lt;M-f&gt; :CtrlSF&lt;CR&gt; &quot; 键入快捷键alt+f，搜索光标当前字符串的匹配项 ctrlsf通过p键可以定位到匹配项的完整代码，类似跳转功能，键入q退出插件。 内容替换更多请参考 所需及所获:像使用IDE一样使用vim 4.9节。 vim-multiple-cursors 配合ctrlsf插件，实现多个不同位置的字符串替换。.vimrc文件中添加如下配置: 1Plugin &apos;terryma/vim-multiple-cursors&apos; 123456&quot; set multiple-sursorslet g:multi_cursor_use_default_mapping=0let g:multi_cursor_next_key=&apos;&lt;S-n&gt;&apos;let g:multi_cursor_prev_key=&apos;&lt;S-p&gt;&apos;let g:multi_cursor_skip_key=&apos;&lt;S-s&gt;&apos;let g:multi_cursor_quit_key=&apos;&lt;ESC&gt;&apos; S表示Shift键。在通过ctrlsf插件列举处匹配项后，则可以通过快捷键S-n选中当前匹配项并跳到下一个匹配项，键入S-s则可以跳过当前项而选中下一个，可以通过S-p回退到前一个匹配项。键入Esc推出插件。 Vim自带很强大的替换功能，这里就不介绍了。建议了解一哈，一般会看这篇文档的，都有可能在面试的时候被提问。-_- 文件搜索1Plugin &apos;Yggdroot/LeaderF&apos; ctrlP 和LeaderF 插件都能实现文件搜索功能，ctrlP在网上搜索就能找到配置方法，这里不介绍。这里使用的LeaderF在网上资料不多，看作者的介绍操作，暂时还不够熟悉，后续补充。 快速注释更多请参考 所需及所获:像使用IDE一样使用vim 5.1节。 NERD Commenter 能够快速注释/取消注释，并且提供不同的注释方式。在.vimrc文件中添加配置: 1Plugin &apos;scrooloose/nerdcommenter&apos; 12345&quot; set nerdcommentermap &lt;M-c&gt; &lt;Leader&gt;cc &quot; add commentmap &lt;M-u&gt; &lt;Leader&gt;cu &quot; cancel commentmap &lt;M-a&gt; &lt;Leader&gt;ca &quot; switch /* */ &amp; //let g:NERDSpaceDelims=1 &quot; 强制在注释符旁边增加一个空格 在Vim normal模式下，键入v或者V进入可视化模式，通过h/j/k/l选中需要注释的部分，键入快捷键alt+c则注释当前选中代码。反之，选中需要取消注释的部分，键入快捷键alt+u取消注释。alt+a可以切换注释方式:/* */或者//，但这个快捷键定义跟某些有冲突，将就可用，也可以自定义其他。 行尾空格这个插件是我在知乎的一个回答中了解到的，有实用性，提供参考。贴上这个知乎的帖子:https://www.zhihu.com/question/19989337写程序时，虽然行尾的空格都看不见，遇上了的话，有点强迫症的肯定受不了。为了能够显示行尾的空格，需要ShowTrailingWhiteSpace这个插件。在.vimrc中添加如下内容: 1Plugin &apos;vim-scripts/ShowTrailingWhiteSpace&apos; 123&quot; set ShowTrailingWhitespacelet g:ShoeTrailingWhitespace=1 &quot; default ON; 1 on, 0 offhighlight ShowTrailingWhitespace ctermbg=Red guibg=Red &quot; 可以理解为高亮行尾空格 帖子中的回答者，还提供了一个快捷键，自动清理文件中所有行尾的空格: 12&quot;strip all trailing whitespace in the current filennoremap &lt;leader&gt;w :%s/\\s\\+$//&lt;cr&gt;:let @/=&apos;&apos;&lt;CR&gt; 我自己改变了一哈，每次保存文件(所有格式的文件)的时候，自动清除当前文件中所有行尾的空格: 12&quot;autocmd BufWritePre *.c,*.cpp,*.h,*.sh, :%s/\\s\\+$//eautocmd BufWritePre * :%s/\\s\\+$//e 注释掉的配置，表示只在这几个类型的文件执行保存文件命令时自动清除行尾空格，文件类型自己根据需要添加。 补全主要介绍三种补全:模板补全，基于标签的补全，基于语义的补全。 模板补全: 更多请参考 所需及所获:像使用IDE一样使用vim 5.2节。 ultisnips 提供相同代码段的快速输入，比如if-else、switch-case语句。在.vimrc文件中添加如下配置: 12Plugin &apos;SirVer/ultisnips&apos;&quot;Plugin &apos;honza/vim-snippets&apos; ultisnips补全时用于选中的键为tab，与后面将要提到的插件YCM的快捷键有冲突，所以提供改建的配置方式。个人选择改YCM的快捷键。 1234&quot; set ultisnips&quot;let g:UltiSnipsExpandTrigger=&quot;&lt;Leader&gt;&lt;tab&gt;&quot;&quot;let g:UltiSnipsJumpForwardTrigger=&quot;&lt;M-n&gt;&quot;&quot;let g:UltiSnipsJumpBackwardTrigger=&quot;&lt;M-m&gt;&quot; 另外需要说明的一点是，下载ultisnips插件后，默认是没有提供模板补全用的文件的。需要自己下载。一种方式时安装插件vim-snippets，复制~/.vim/bundle/vim-snippets/UltiSnips整个文件夹到~/.vim/bundle/ultisnips目录下面即可。另一种是自己到github上去下载， https://github.com/honza/vim-snippets ，其实内容都是一样的。我认为这个插件最好的点是支持自己定义，很强大。 基于标签的补全: 详情请参考 所需及所获:像使用IDE一样使用vim 5.3节部分。 基于语义的补全: 更多请参考 所需及所获:像使用IDE一样使用vim 5.3节部分。 YouCompleteMe 插件在安装过程中，参看文章的作者以及很多其他介绍YCM插件使用的作者都有说到，YCM原作者建议下载LLVM官网提供的预编译二进制文件，以避免各种问题。但我按照教程介绍，最后编译生成始终只有一个ycm_core.so文件，也没有查找到原因，待优化。然后后面我是按照YCM原作者Git项目中README.md文件中Ubuntu Linux x64部分实现安装的，不需要手动下载库，按作者的顺序执行即可，需要比较长的时间。需要确认已安装Cmake、python-dev、python3-dev，没有的话请自行安装。更多请自行阅读原作者 README.md 。 YCM插件需要在.vimrc文件中添加配置: 1Plugin &apos;Valloric/YouCompleteMe&apos; 123456789101112131415&quot; set YouCompleteset runtimepath+=~/.vim/bundle/YouCompleteMelet g:ycm_collect_identifiers_from_tags_files=1 &quot; 开启YCM标签补全let g:ycm_complete_in_comments=1 &quot; 补全功能在注释中同样有效let g:ycm_seed_identfiers_with_syntax=1 &quot; 语法关键字补全let g:ycm_confirm_extra_conf=0 &quot; 允许VIM加载.ycm_extra_conf.py 文件，不再提示let g:ycm_key_list_select_completion=[&apos;&lt;M-n&gt;&apos;, &quot;&lt;Down&gt;&quot;] &quot; 补全列表中 向下选中let g:ycm_key_list_previous_completion=[&apos;&lt;M-m&gt;&apos;, &quot;&lt;Up&gt;&quot;] &quot; 补全列表中 向上选中let g:ycm_min_num_of_chars_for_completion=2 &quot; 从第2个键入字符就开始罗列匹配项let g:ycm_cache_comnifunc=0 &quot; 禁止缓存匹配项，每次都重新生成匹配项&quot; 加载.ycm_extra_conf.py 文件的路径，可以不用每个工程目录下都去添加这个文件let g:ycm_global_ycm_extra_conf=&apos;~/.vim/bundle/YouCompleteMe/third_part/ycmd/cpp/ycm/.ycm_extra_conf.py&apos;&quot;nnoremap &lt;M-=&gt; :YcmCompleter GoToDefinition&lt;CR&gt; &quot; 跳转到声明/定义的位置，在前面跳转部分有介绍&quot;nnoremap &lt;c-j&gt; :YcmCompleter GoToDefinitionElseDeclaration&lt;CR&gt;nnoremap &lt;M-=&gt; :YcmCompleter GoToDefinitionElseDeclaration&lt;CR&gt; 另外还需要配置.ycm_extra_conf.py文件以及引入标签补全，这里就不做详述，请自行参考介绍。 工程文件管理NERDtree可以查看文件列表，要打开哪个文件，光标选中后回车即可在新buffer中打开。在.vimrc文件中添加如下配置: 1Plugin &apos;scrooloose/nerdtree&apos; 123456789&quot; set NERDTreenmap &lt;F9&gt; :NERDTreeToggle&lt;CR&gt;let NERDTreeShowBookmarks=1 &quot; set NERDTree book marks default onlet NERDTreeIgnore=[&apos;\\.py[cd]$&apos;, &apos;\\~$&apos;, &apos;\\.swo$&apos;, &apos;\\.swp$&apos;, &apos;^\\.git$&apos;, &apos;^\\hg$&apos;, &apos;^\\.svn$&apos;, &apos;\\.bzr$&apos;]let NERDTreeWinSize=32 &quot; set widthlet NERDTreeWinPos=&quot;right&quot; &quot; set positionlet NERDTreeShoeHidden=1 &quot; show the hidden fileslet NERDTreeMinimalUI=1 &quot; the window tags not show help infolet NERDTreeAutoDeleteBuffer=1 &quot; Automatically deletes files when deletes files buffer 更多请参考 所需及所获:像使用IDE一样使用vim 6.1节部分。 多文件编辑Vim中每打开一个文件Vim就对应创建一个buffer，多个文件就有多个buffer，但默认你只看得到最后buffer对应的Window，通过插件MiniBufExplorer可以切换到不同的buffer及达到编辑多个文件的功能。在.vimrc文件中添加配置: 1Plugin &apos;fholgado/minibufexpl.vim&apos; 12345&quot; set minibuffexploermap &lt;M-q&gt; :bn&lt;CR&gt; &quot; 切换多个buffer时的快捷键map &lt;M-w&gt; :bp&lt;CR&gt;&quot; 这个设置，网上我查到两种说法，一个是在gvim下时防止出现多窗口，一种是自动打开。实际情况看，无论是0/1，在只有一个文件时都会显示nimibufferlet g:let g:miniBufExplorerMoreThanOne=1 buffer快捷切换时，只需要在当前编辑文件中normal下按快捷键切换(需要存在多个buffer)，但是删除buffer时，需要将光标定位到buffer标签上。键入d删除光标所在buffer。 更多请参考 所需及所获:像使用IDE一样使用vim 6.2节部分。 自动对齐1Plugin &apos;godlygeek/tabular&apos; &quot; 自动对齐 后续补充。可自行搜索。 MarkdownMarkdown就不多解释了，在Vim编辑过程中最大的需求就是实时预览，在这里介绍插件markdown-preview，能够实现在浏览器中实时预览，默认是谷歌浏览器Chorme，自行下载。需要说明的是，这款插件在Github上比较多，比如markdown-preview，不需要浏览器支持即可实时预览，供君选择。vim-markdown 是一个语法高亮插件，根据实际情况使用。 在.vimrc文件中添加配置: 12Plugin &apos;plasticboy/vim-markdown&apos;Plugin &apos;iamcco/markdown-preview.vim&apos; 123456789&quot; set markdownlet g:mkdp_auto_start=0 &quot; set 1, the vim will auto open preview window once enter markdown bufferlet g:mkdp_auto_open=0 &quot; set 1, the vim will auto open preciew window when you edit the markdown filelet g:mkdp_auto_close=1 &quot; set 1, the vim will auto close current preview window when change from markdown buffer to another buflet g:mkdp_refresh_slow=0 &quot; set 1, the vim will just refresh markdown when save the buffer or leave frim insert mode,default 0 islet g:mkdp_command_for_global=0 &quot; set 1, the markdown preview command can be use for all files, by default it just can be use in markdolet g:mkdp_path_to_chrome=&quot;google-chrome&quot;map &lt;F6&gt; &lt;Plug&gt;MarkdownPreviewmap &lt;F7&gt; &lt;Plug&gt;StopMarkdownPreview 基本上都是默认配置，除了打开/关闭的快捷键映射。更多的话，可以自己到Github看作者介绍。 其他配置文件模板新建源文件时，一般都会添加一些文件信息在文件开始的位置处。常见比如文件名、作者、创建时间、文件简介等等，如果每次都手动添加，就会很麻烦。所以可以通过添加脚本函数的方式，实现文件新建时自动添加。在这里贴上一个.vimrc文件的配置，可以参考他的实现方式: https://github.com/taizilongxu/dotfiles/blob/master/vimrc 。文件中其他也可以参考。注意一点，如果需要判断是否为*.h文件，头文件，请使用if expand(&quot;%:e&quot;)==&#39;h&#39;进行判断。 自动添加时间需要的话也是通过脚本函数实现。.vimrc文件中添加配置: 123456789autocmd BufWritePre,FileWritePre *.c,*.h,*.sh,*.py ks|call LastChanged()|&apos;sfunc! LastChanged() &quot; auto add last changed date if line (&quot;$&quot;) &gt; 15 let l = 15 else let l = line(&quot;$&quot;) endif exe &quot;1,&quot;.l.&quot;g/Last Changed : /s/Last Changed : .*/Last Changed : &quot;.strftime(&quot;%c&quot;)endfunc 关于这一段的解释和详细介绍请参考: http://www.cnblogs.com/soli/archive/2009/10/21/885044.html 。 结束语第一次的环境配置就先这样了，后续有其他好用插件，会再推荐。文中还有没写完整的，会尽快补充。没有特别认真的写，比较水，希望不要介意，能够提供一丁点的帮助，我觉得也是好的。谢谢。 参考1、所需及所获:像使用IDE一样使用vim2、.vimrc3、.vimrc4、.vimrc5、vim配置技巧——在vim中使用autocmd命令在保存文件时自动插入最后修改日期和时间6、Vim与Markdown共舞7、NERD_commenter安装和使用","tags":[{"name":"VIM","slug":"VIM","permalink":"https:/jungleeee.github.io.git/tags/VIM/"}]}]