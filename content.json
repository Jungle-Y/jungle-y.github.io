[{"title":"STM32-ROS串口通信(FreeRTOS + ROSlib)","date":"2018-12-06T06:51:45.098Z","path":"2018/12/06/freertos-roslib/","text":"前言1学习、总结、交流、进步！ 测试环境为Keil 5.20 &amp;&amp; STM32F405VGT6 &amp;&amp; FreeRtos 10.0.0；晶振频率为12Mhz。请根据实际情况修改后进行测试。 原创，转载请注明出处。 介绍ROS(Robot Operating System）是一个机器人软件平台(本人不够熟悉，只有简单使用。不多哔哔）。这里主要介绍如何实现SMT32控制器如何实现跟ROS进行同行和数据交互：1、ROS端和STM32端自主定义协议，在ROS端（如ubuntu）做串口驱动，实现协议解析，再将数据发送到相应topic。2、STM32端解析和封装ROS协议。3、移植ROSLib，将STM32作为节点加入到ROS系统中（就是库本身实现了ROS协议的解析的封装）。 使用方案3。 ROSLIBROSlib是arduino下支持ROS的库，C++编写。（至于如何获取arduino IDE下ROSlib库，本人没实际操作，不多哔哔）。在做移植过程中，主要参考 基于STM32的rosserial_client的节点开发。(主要移植步骤文中阐述的比较清楚，不多哔哔)。 建议一步一步搭建，而不是一股脑复制粘贴，因为系统或者Keil版本或者其他因素，都有可能导致错误出来，最好是一点点来。优先搭建好STM32和FreeRTOS，再加入ROSlib(C++)。 因为加入了FreeRTOS系统，系统的Task和queue机制，使得在串口收发处理时有更加便捷和完善的方式。 需要注意的是，由于ROS自定义的消息类型，大部分存在一个消息占用的数据量比较大(几百字节)，所以在设置串口发送任务时的队列大小，需要仔细评估，以免内存浪费或者一帧数据内存不足。在ros_bsp.c文件中，定义为256个字节，根据自身情况调整：。 1234typedef struct ROS_DATA_BLOCK &#123; int xLength; uint8_t xData[256];//ros_MAX_TX_QUEUE_LEN&#125; Ros_Data_Block_Definition_t; ros_bsp.c中提供了stm32Hardware.h需要定义的函数接口，具体查看源码。 ros_bsp.c中ros_communication_bsp_init()函数初始化整个通信需要的任务和串口初始化，默认波特率406800。 ros_test.cpp中创建了两个任务： 1234567891011121314151617181920212223static void node_test_subscribe(void *pvParameters)&#123;//ros端可以通过这个话题像STM32发送消息，收到消息后，调用回调函数 n.subscribe(stm_subscribe); while(1) &#123; n.spinOnce(); ros_dealy_ms(10); &#125;&#125;static void node_test_publish(void *pvParameters)&#123;//STM每一秒中通过这个话题像ROS发送Msg消息：stm publish n.advertise(stm_publish); Msg.data = &quot;stm publish&quot;; for( ;; ) &#123; stm_publish.publish(&amp;Msg); ros_dealy_ms(1000); &#125;&#125; ubuntu启动ROS，后续操作以及现象如下图：1_ros 参考1、基于STM32的rosserial_client的节点开发2、git 上的例子3、ros rosserial_python 用法","tags":[{"name":"STM32","slug":"STM32","permalink":"https:/jungleeee.github.io.git/tags/STM32/"},{"name":"FreeRTOS","slug":"FreeRTOS","permalink":"https:/jungleeee.github.io.git/tags/FreeRTOS/"},{"name":"ROS","slug":"ROS","permalink":"https:/jungleeee.github.io.git/tags/ROS/"},{"name":"ROSlib","slug":"ROSlib","permalink":"https:/jungleeee.github.io.git/tags/ROSlib/"}]},{"title":"Lwip 2.0.3 移植(FreeRTOS + CLI)","date":"2018-12-06T06:43:50.284Z","path":"2018/12/06/lwip/","text":"前言1学习、总结、交流、进步！ 测试环境为Keil 5.20 &amp;&amp; STM32F407ZET6 &amp;&amp; FreeRtos 10.0.0 &amp;&amp; Lwip 2.0.3 &amp;&amp; DP83848；晶振频率为8Mhz。请根据实际情况修改后进行测试。 原创，转载请注明出处。 介绍主要介绍Lwip 2.0.3 的移植过程。 作者对Lwip的认识一点也不深刻，只能简单的记录移植过程中主要的修改位置。方便其他需要使用此协议栈的小伙伴。 在移植开始之前需要下载Lwip最新源码包，以及STM32官方提供的基于STM32F407 &amp;&amp; FreeRTOS &amp;&amp; lwip 1.4.1 &amp;&amp; DP83848 的例程源码。获取方式如下：1、Lwip 直接百度，下载需要的版本。2、百度STSW—STM32070，下载此源码包。 FIRST将上述两个源码包解压。Lwip目录下主要包括doc、src、test三个文件夹，以及一些其他文件（不重要）。所有源文件都在src文件夹下。可以直接将lwip整个文件夹直接放到工程目录下。 然后是ST官方的移植例程。解压后在目录:STM32F4x7_ETH_LwIP_V1.1.1\\Libraries下，请把STM32F4x7_ETH_Driver文件夹移到工程相关目录下。然后在STM32F4x7_ETH_Driver\\inc目录下存在stm32f4x7_eth.h和stm32f4x7_eth_conf_template.h两个文件，打开stm32f4x7_eth.h可以看到有包含头文件#include &quot;stm32f4x7_eth_conf.h&quot;，此处我选择直接将另一个.h文件直接重命名为stm32f4x7_eth_conf.h。此时目录下存在stm32f4x7_eth.h和stm32f4x7_eth_conf.h两个文件。对stm32f4x7_eth_conf.h文件进行如下修改: 123456789101112line 60: #define CUSTOM_DRIVER_BUFFERS_CONFIG //取消注释，允许使用自定义的网络接收/发送的数据缓冲区大小。//此处使用系统较为精确的延时，函数原型如下，请在适当位置进行定义：//void Delay(uint32_t ms)//&#123;// vTaskDelay(ms);//由于使用的FreeRTOS系统，使用系统延时。//&#125;line 51: extern void Delay(uint32_t ms);/* Header file where the Delay function prototype is exported *///在允许使用自定义收发缓存大小后，请根据实际网络收发数据量的大小定义此处大小。line 66: #define ETH_RXBUFNB 4 /* 4 Rx buffers of size ETH_RX_BUF_SIZE */line 67: #define ETH_TXBUFNB 4 /* 4 Tx buffers of size ETH_TX_BUF_SIZE */ SECOND在工程目录下的lwip文件夹下创建arch文件夹，用来存放其他文件。ST官方例程目录STM32F4x7_ETH_LwIP_V1.1.1\\Utilities\\Third_Party\\lwip-1.4.1\\port下，是针对于f4x7系列写的相关程序（具体作用还未详细了解）。接下来把部分源文件复制到新建的arch文件夹中，因为使用了FreeRTOS系统，所以需要注意选择FreeRTOS目录下的文件：1、把STM32F4x7_ETH_LwIP_V1.1.1\\Utilities\\Third_Party\\lwip-1.4.1\\port\\STM32F4x7\\arch目录下cc.h cpu.h perf.h三个文件。2、把STM32F4x7_ETH_LwIP_V1.1.1\\Utilities\\Third_Party\\lwip-1.4.1\\port\\STM32F4x7\\FreeRTOS目录下全部四个文件。3、把STM32F4x7_ETH_LwIP_V1.1.1\\Project\\FreeRTOS\\httpserver_socketi\\inc目录下lwipopts.h一个文件。总共8个文件复制到新建arch目录下。 还需要将目录STM32F4x7_ETH_LwIP_V1.1.1\\Project\\FreeRTOS\\httpserver_socket\\src下stm32f4x7_eth_bsp.c以及目录STM32F4x7_ETH_LwIP_V1.1.1\\Project\\FreeRTOS\\httpserver_socket\\inc下stm32f4x7_eth_bsp.h复制到工程相关目录下。作如下修改： 1234567891011文件不要随意改变，不然行数对不上。1、`stm32f4x7_eth_bsp.h`: line 38-48 注释掉。 line 74-78 注释掉。 添加宏定义：#define RMII_MODE //use MII，因为我这里硬件使用的时MII接口，根据硬件接口情况定义使用MII或者RMII。2、`stm32f4x7_eth_bsp.c`: line 32 注释掉：#include &quot;main.h&quot; lin3 34 #include &quot;netconf.h&quot;修改为#include &quot;ethernetif.h&quot; line 81-101 注释掉。这里定义和创建网线链接检测的认为，我硬件上无此设计，所以注释掉，不使用。 line 132-133 源文件是注释掉的，取消注释。 line 294-556 全部注释掉。这里配置网线链接的硬件IO。 THIRD按下图将文件相应文件添加到工程中(这里需要注意：源文件ethernetif.c、sys_arch.c 在前面创建的文件夹arch下)： 此时如果进行编译的话，会出现较多警告和错误，下面进行一一处理（情况不一定完全一样，这里解决我出现的现象）： 12345678910111213141516171、 error: #256: invalid redeclaration of type name &quot;u32_t&quot; (declared at line 41 of &quot;..\\..\\_Code\\LWIP\\arch/cc.h&quot;)这里在`arch.h`和`cc.h`两个文件中出现了重复定义。请将`arch.h` - `line 113` - `#define LWIP_NO_STDINT_H 0` - 定义为1：`#define LWIP_NO_STDINT_H 1`2、 error directive: &quot;LWIP_COMPAT_MUTEX cannot prevent priority inversion. It is recommended to implement priority-aware mutexes. (Define LWIP_COMPAT_MUTEX_ALLOWED to disable this error.)&quot;请在`lwipopts.h`文件中添加：`#define LWIP_COMPAT_MUTEX_ALLOWED 0`3、 error: #5: cannot open source input file &quot;lwip/timers.h&quot;: No such file or directory请注释掉`ethernetif.c`中`#include &quot;lwip/timers.h&quot;`，同时注释掉`#include &quot;main.h&quot;`，这是例程中有相关的定义，这里重新定义，所以注释掉。注释掉后，就会出现信号量声明未定义的错误，需要添加相应头文件：`#include &quot;FreeRTOS.h&quot; #include &quot;task.h&quot; #include &quot;semphr.h&quot;`然后会出现MAC地址未定义的错误，这里直接将宏定义修改为数字就可以解决了。在MAX地址初始化下面位置，设置`netif-&gt;flags = NETIF_FLAG_BROADCAST | NETIF_FLAG_ETHARP;`的位置请添加`NETIF_FLAG_LINK_UP`，为`netif-&gt;flags = NETIF_FLAG_BROADCAST | NETIF_FLAG_ETHARP | NETIF_FLAG_LINK_UP;`，否则网络无法连接。4、 warning: #223-D: function &quot;sys_timeout&quot; declared implicitly直接注释，不使用。5、 warning: #177-D: function &quot;arp_timer&quot; was declared but never referenced直接注释，不使用。 FOURTH理论上应该没有什么编译警告和错误了。然后因为ST官方例程中使用的网络的DMA进行收发控制，所以还需构造网络中断函数，实际上在例程的stm32f4xx_it.c文件中有。为了不进行信号量的外部声明，我把中断函数直接放到了ethernetif.c中。 1234567891011121314151617181920212223void ETH_IRQHandler(void)&#123; portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE; // Frame received if ( ETH_GetDMAFlagStatus(ETH_DMA_FLAG_R) == SET) &#123; // Give the semaphore to wakeup LwIP task xSemaphoreGiveFromISR( s_xSemaphore, &amp;xHigherPriorityTaskWoken ); &#125; // Clear the interrupt flags. // Clear the Eth DMA Rx IT pending bits ETH_DMAClearITPendingBit(ETH_DMA_IT_R); ETH_DMAClearITPendingBit(ETH_DMA_IT_NIS); // Switch tasks if necessary. if( xHigherPriorityTaskWoken != pdFALSE ) &#123; portEND_SWITCHING_ISR( xHigherPriorityTaskWoken ); &#125;&#125; FIFTH到此整个工程文件移植完成，接下来构造进行初始化函数。如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106/* Inlcude ---------------------------------------------------------------------*/#include &quot;stdio.h&quot;#include &quot;stdint.h&quot;#include &quot;string.h&quot;#include &quot;tcpip.h&quot;#include &quot;ethernetif.h&quot;#include &quot;stm32f4x7_eth_bsp.h&quot;#include &lt;lwip/sockets.h&gt;#include &lt;lwip/err.h&gt;#include &lt;lwip/sys.h&gt;/** @addtogroup Cli_Project * @&#123; *//* Private typedef -------------------------------------------------------------*//* Private constants define ----------------------------------------------------*//* Static IP ADDRESS */#define IP_ADDR0 192#define IP_ADDR1 168#define IP_ADDR2 11#define IP_ADDR3 241/* NETMASK */#define NETMASK_ADDR0 255#define NETMASK_ADDR1 255#define NETMASK_ADDR2 255#define NETMASK_ADDR3 0/* Gateway Address */#define GW_ADDR0 192#define GW_ADDR1 168#define GW_ADDR2 11#define GW_ADDR3 1/* Private macro define --------------------------------------------------------*//* Private variables -----------------------------------------------------------*/struct netif xnetif;/* Private function declaration ------------------------------------------------*//* Private functions -----------------------------------------------------------*//** * @brief Initializes the lwIP stack * @param None * @retval None */void network_lwip_init(void)&#123; struct ip4_addr ipaddr; struct ip4_addr netmask; struct ip4_addr gw;#ifndef USE_DHCP// uint8_t iptab[4] = &#123;0&#125;;// uint8_t iptxt[20];#endif /* Create tcp_ip stack thread */ tcpip_init( NULL, NULL ); /* IP address setting */#ifdef USE_DHCP ipaddr.addr = 0; netmask.addr = 0; gw.addr = 0;#else IP4_ADDR(&amp;ipaddr, IP_ADDR0, IP_ADDR1, IP_ADDR2, IP_ADDR3); IP4_ADDR(&amp;netmask, NETMASK_ADDR0, NETMASK_ADDR1 , NETMASK_ADDR2, NETMASK_ADDR3); IP4_ADDR(&amp;gw, GW_ADDR0, GW_ADDR1, GW_ADDR2, GW_ADDR3);#endif /* - netif_add(struct netif *netif, struct ip_addr *ipaddr, struct ip_addr *netmask, struct ip_addr *gw, void *state, err_t (* init)(struct netif *netif), err_t (* input)(struct pbuf *p, struct netif *netif)) Adds your network interface to the netif_list. Allocate a struct netif and pass a pointer to this structure as the first argument. Give pointers to cleared ip_addr structures when using DHCP, or fill them with sane numbers otherwise. The state pointer may be NULL. The init function pointer must point to a initialization function for your ethernet netif interface. The following code illustrates it&apos;s use.*/ netif_add(&amp;xnetif, &amp;ipaddr, &amp;netmask, &amp;gw, NULL, ethernetif_init, tcpip_input); /* Registers the default network interface.*/ netif_set_default(&amp;xnetif); /* When the netif is fully configured this function must be called.*/ netif_set_up(&amp;xnetif);&#125;/** * @brief : * @param : None * @retval : None */void network_init(void)&#123; /* configure ethernet (GPIOs, clocks, MAC, DMA) */ ETH_BSP_Config();//这个函数在stm32f4x7_eth_bsp.c 中定义 network_lwip_init();//这个函数也就是上文定义的函数，源码在ST官方工程中的main.c文件中，main函数中的`LwIP_Init()`函数便是，我这里只使用了前面一部分。具体查看原函数。&#125; 把network_init()添加到初始化中去。进行调测。可以通过ping IP 地址简单验证网络是否连通。然后在建立TCP SERVER，可以用SecureCRT连接，验证数据收发。 NOTICE1、我在调试过程中，出现了初始化一切正常，但ping IP 地址始终ping不通。后来调试发现初始化过程中有bug： 在`stm32f4x7_eth.c`文件`ETH_Init`函数中，以下代码 1234do&#123; timeout++;&#125; while (!(ETH_ReadPHYRegister(PHYAddress, PHY_BSR) &amp; PHY_Linked_Status) &amp;&amp; (timeout &lt; PHY_READ_TO)); 函数 ETH_ReadPHYRegister(PHYAddress, PHY_BSR)前几次获取的值为0x0000ffff，导致此处初始化通过，实际该值并不正确（可以通过打印该值看现象）。 所以我把此处修改为(总共有三处，只修改可第一处位置)： 12345678int get_PHY_Linked_Status = 0;do&#123; get_PHY_Linked_Status = ETH_ReadPHYRegister(PHYAddress, PHY_BSR); //printf(&quot;******* 0x%08x. \\r\\n&quot;, get_PHY_Linked_Status); get_PHY_Linked_Status = ((get_PHY_Linked_Status == 0x0000ffff) ? 0 : get_PHY_Linked_Status); timeout++;&#125; while (!(get_PHY_Linked_Status &amp; PHY_Linked_Status) &amp;&amp; (timeout &lt; PHY_READ_TO)); 但此处还存在一个bug，就是如果网线未插，这一直会停在此处，所以请务必注意，进行优化处理。 源码链接","tags":[{"name":"STM32","slug":"STM32","permalink":"https:/jungleeee.github.io.git/tags/STM32/"},{"name":"FreeRTOS","slug":"FreeRTOS","permalink":"https:/jungleeee.github.io.git/tags/FreeRTOS/"},{"name":"CLI","slug":"CLI","permalink":"https:/jungleeee.github.io.git/tags/CLI/"},{"name":"LWIP","slug":"LWIP","permalink":"https:/jungleeee.github.io.git/tags/LWIP/"}]},{"title":"STM32命令行调试工具 (FreeRTOS + CLI)","date":"2018-12-06T06:42:25.086Z","path":"2018/12/06/freertos-cli/","text":"前言1学习、总结、交流、进步！ 测试环境为Keil 5.20 &amp;&amp; STM32F405ZET6 &amp;&amp; FreeRtos 10.0.0；晶振频率为12Mhz。串口工具使用的SecureCRT，波特率为115200。请根据实际情况修改后进行测试。 原创，转载请注明出处。 介绍在系统调试过此中，总是会有某些参数的临时修改，或者有时候调试需要临时打印一些信息，如果都需要重新修改代码、编译、下载这样一个过程就会显得十分麻烦。而通过CLI接口，就可以通过调用程序中的接口去修改一些参数，或者临时打开一些预置的调试打印，避免反复修改程序的麻烦和偶尔粗心大意造成的修改不全面。当然还可以通过一些控制接口，直接实现一些控制，方便调试。总之而言，CLI很大程度方便了程序调试过程。FreeRTOS系统后续不做介绍，作者只是选择了一个系统平台来实现和展示CLI工具。更新了基于UcOSIII的CLI(2018.4.2, STM32F4), 队列、信号量的实现方式不同于FreeRTOS，所以差异还是比较明显，可以一起看看。 CLIFreeRTOS官网提供CLI的例程，作者自写CLI之前很认真的阅读过源码，并且有实际使用。但在使用过程中发现一点小小的不方便，于是便自己尝试修改，并于分享。作者在使用FreeRTOS提供的CLI过程中，发现当系统中要使用的调试命令太多时，输入’help’后出现一大串命令介绍，你需要在这一大串命令中去找要使用的命令的使用格式，很麻烦。所以在修改后实现了二级命令菜单，可以通过某些属性，将命令简单分类，原因之一。另一原因是，大多数人在打印调试信息时，都会使用重新映射的’printf’，而它的执行过程是一直阻塞直到全部发送完成，当调式信息过多时，就会影响系统的实时性。因此作者想要通过串口的DMA来完成调试信息的打印，而不使用前一种方式，其次为系统提供统一可控制的打印接口，可以随意开启/关闭某一分类的调试打印输出。 实现的源码在目录_Code/_APP下，源码很简单，就不做流程介绍了。主要说明几点注意事项(Notice)： 123456789101112131、usart.c: line: 127-129: DMA_Cmd(..., DISABLE);//must disable2、common.h: line 28-37, bit-field(位域)，baidu or google。 if you need to add one bit, please reduce one bit on &apos;OTHER&apos;3、about submenu, please refer to the template in the file cli_register.c4、The critical area problem is not considered in the program, and it is not recommended to use in interrupts, and high frequency is not recommended.5、Provide the program under the ucos system.6、Use caution if you don&apos;t do a lot of testing. 源码链接 参考1、FreeRTOS+CLI","tags":[{"name":"STM32","slug":"STM32","permalink":"https:/jungleeee.github.io.git/tags/STM32/"},{"name":"FreeRTOS","slug":"FreeRTOS","permalink":"https:/jungleeee.github.io.git/tags/FreeRTOS/"},{"name":"CLI","slug":"CLI","permalink":"https:/jungleeee.github.io.git/tags/CLI/"}]},{"title":"STM32(Cortex-M4) 时钟配置","date":"2017-09-22T03:18:51.462Z","path":"2017/09/22/stm32-clock/","text":"前言1学习、总结，交流，进步！ 测试环境为Keil 5.20 &amp;&amp; (STM32F405ZET6 || STM32F407ZET6)。外部晶振频率不同，就需要配置时钟以此获知各外设的时钟频率，比如常用的定时器。 原创，转载请注明出处。 时钟树介绍介绍时钟配置之前，安利一个ST的针对于STM32提供的一个软件，STM32CubeMX，常用来进行硬件选型，外设资源分配以及可以进行配置生成基于HAL库的配置程序等功能。当然了，大多数都应该知道这个软件，就不赘述了。其中还有一个功能是提供时钟树的配置，配置后可以直观的看到各个部分/外设的工作时钟，个人觉得挺好的，如下图所示： 这里简单介绍上图(从左到右)：红色外框：从这里选中HSE(外部时钟)，并配置外部时钟的频率。(我这里外部晶振使用的是8MHz，内部时钟部分自行参考)黑色外框：M N P参数，常说的倍频部分。黄色外框：通过设置倍频系数，得到的系统频率。(系统最大频率，请参考计数文档)绿色外框：AHB 分频得到HCLK频率。蓝色外框：下面两个框分频后得到APB1和APB2的时钟。最后面是到各个外设的工作频率。 时钟配置时钟配置其实最主要的就是设置倍频和分频的系数，很简单。这里就这几个系数在什么位置说明一下，请打开system_stm32f4xx.c文件。这里使用的是F4的库，STM32F4xx_DSP_StdPeriph_Lib_V1.8.0，芯片f405/f407，所以在Keil中定义了STM32F40_41xxx(根据此宏确定该系数的唯一位置)，下面程序是截取system_stm32f4xx.c文件，需要修改的位置在程序中有说明，请仔细查看这一部分。首先我们需要修改外部时钟的频率，改为外部使用的晶振频率，是在系统文件stm32f4xx.h中：1234567891011121314151617/** * @brief In the following line adjust the value of External High Speed oscillator (HSE) used in your application Tip: To avoid modifying this file each time you need to use different HSE, you can define the HSE value in your toolchain compiler preprocessor. */#if defined(STM32F40_41xxx) || defined(STM32F427_437xx) || defined(STM32F429_439xx) || defined(STM32F401xx) || \\ defined(STM32F410xx) || defined(STM32F411xE) || defined(STM32F469_479xx) #if !defined (HSE_VALUE) /* 修改外部时钟频率，默认25MHz，25000000，我使用8MHz， */ #define HSE_VALUE ((uint32_t)8000000) /*!&lt; Value of the External oscillator in Hz */ #endif /* HSE_VALUE */#elif defined (STM32F412xG) || defined(STM32F413_423xx) || defined(STM32F446xx) #if !defined (HSE_VALUE) #define HSE_VALUE ((uint32_t)8000000) /*!&lt; Value of the External oscillator in Hz */ #endif /* HSE_VALUE */#endif /* STM32F40_41xxx || STM32F427_437xx || STM32F429_439xx || STM32F401xx || STM32F411xE || STM32F469_479xx */ 然后倍频的系数设置：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/************************* PLL Parameters *************************************/#if defined(STM32F40_41xxx) || defined(STM32F427_437xx) || defined(STM32F429_439xx) || defined(STM32F401xx) || defined(STM32F469_479xx) /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLL_M) * PLL_N */ #define PLL_M 8//25 /******** 修改PLL_M系数，源文件中默认为25，因为ST默认使用25MHz晶振。修改为8分频是根据前面时钟树的配置进行修改 ********/#elif defined(STM32F412xG) || defined (STM32F446xx) #define PLL_M 8#elif defined (STM32F410xx) || defined (STM32F411xE) #if defined(USE_HSE_BYPASS) #define PLL_M 8 #else /* !USE_HSE_BYPASS */ #define PLL_M 16 #endif /* USE_HSE_BYPASS */#else#endif /* STM32F40_41xxx || STM32F427_437xx || STM32F429_439xx || STM32F401xx || STM32F469_479xx *//* USB OTG FS, SDIO and RNG Clock = PLL_VCO / PLLQ */#define PLL_Q 7#if defined(STM32F446xx)/* PLL division factor for I2S, SAI, SYSTEM and SPDIF: Clock = PLL_VCO / PLLR */#define PLL_R 7#elif defined(STM32F412xG)#define PLL_R 2#else#endif /* STM32F446xx */#if defined(STM32F427_437xx) || defined(STM32F429_439xx) || defined(STM32F446xx) || defined(STM32F469_479xx)#define PLL_N 360/* SYSCLK = PLL_VCO / PLL_P */#define PLL_P 2#endif /* STM32F427_437x || STM32F429_439xx || STM32F446xx || STM32F469_479xx */#if defined (STM32F40_41xxx)#define PLL_N 336 /******** 修改PLL_N，根据前面时钟树的配置进行修改 ********//* SYSCLK = PLL_VCO / PLL_P */#define PLL_P 2 /******** 修改PLL_P，根据前面时钟树的配置进行修改 ********/#endif /* STM32F40_41xxx */#if defined(STM32F401xx)#define PLL_N 336/* SYSCLK = PLL_VCO / PLL_P */#define PLL_P 4#endif /* STM32F401xx */#if defined(STM32F410xx) || defined(STM32F411xE) || defined(STM32F412xG)#define PLL_N 400/* SYSCLK = PLL_VCO / PLL_P */#define PLL_P 4#endif /* STM32F410xx || STM32F411xE *//******************************************************************************/ 下面程序截取自system_stm32f4xx.c文件中设置时钟的函数，时钟初始化设置。分频部分的系数设置：12345678910111213141516171819202122232425262728293031323334353637383940414243static void SetSysClock(void)&#123;#if defined(STM32F40_41xxx) || defined(STM32F427_437xx) || defined(STM32F429_439xx) || defined(STM32F401xx) || defined(STM32F412xG) || defined(STM32F446xx)|| defined(STM32F469_479xx)/******************************************************************************//* PLL (clocked by HSE) used as System clock source *//******************************************************************************/ __IO uint32_t StartUpCounter = 0, HSEStatus = 0; /* Enable HSE */ RCC-&gt;CR |= ((uint32_t)RCC_CR_HSEON); /* Wait till HSE is ready and if Time out is reached exit */ do &#123; HSEStatus = RCC-&gt;CR &amp; RCC_CR_HSERDY; StartUpCounter++; &#125; while((HSEStatus == 0) &amp;&amp; (StartUpCounter != HSE_STARTUP_TIMEOUT)); if ((RCC-&gt;CR &amp; RCC_CR_HSERDY) != RESET) &#123; HSEStatus = (uint32_t)0x01; &#125; else &#123; HSEStatus = (uint32_t)0x00; &#125; if (HSEStatus == (uint32_t)0x01) &#123; /* Select regulator voltage output Scale 1 mode */ RCC-&gt;APB1ENR |= RCC_APB1ENR_PWREN; PWR-&gt;CR |= PWR_CR_VOS; /* HCLK = SYSCLK / 1*/ RCC-&gt;CFGR |= RCC_CFGR_HPRE_DIV1; /******** AHB 分频，通过对sysclk分频后得到HCLK时钟频率，此处1分频 ********/#if defined(STM32F40_41xxx) || defined(STM32F427_437xx) || defined(STM32F429_439xx) || defined(STM32F412xG) || defined(STM32F446xx) || defined(STM32F469_479xx) /* PCLK2 = HCLK / 2*/ RCC-&gt;CFGR |= RCC_CFGR_PPRE2_DIV8;//RCC_CFGR_PPRE2_DIV2; /******** APB2 分频，通过对前面HCLK分频后得到，PCLK2时钟频率，默认2分频，根据前面时钟树配置为8分频 ********/ /* PCLK1 = HCLK / 4*/ RCC-&gt;CFGR |= RCC_CFGR_PPRE1_DIV4;//RCC_CFGR_PPRE1_DIV4; /******** APB1 分频，通过对前面HCLK分频后得到，PCLK1时钟频率，默认4分频，根据前面时钟树配置为4分频不变 ********/#endif /* STM32F40_41xxx || STM32F427_437x || STM32F429_439xx || STM32F412xG || STM32F446xx || STM32F469_479xx */ 其实通过这样简单几步设置，时钟配置就完成了，各个部分的时钟如前面图片所示。接下来我们通过库函数来获取HCLK，PCLK1和PCLK2的时钟频率。在函数库文件stm32f4xx_rcc.c中提供函数RCC_GetClocksFreq来获取SYSCLK，HCLK，PCLK1和PCLK2的时钟频率：123RCC_ClocksTypeDef rcc_clock; /* 结构体，成员就是4个时钟频率 */RCC_GetClocksFreq(&amp;rcc_clock); 通过串口将结构体成员的值打印出来，就可以很直观的知道各个外设的时钟频率了。其实在函数库文件stm32f4xx_rcc.c中还有设置AHB，APB1和APB2分频系数的函数，这里不做介绍，具体请参考此文件。 结束语时钟配置的过程很简单，我觉得更重要的是熟悉STM32的时钟结构，各个外设使用的是哪个部分的时钟，这样才能在使用的时候少犯错，尤其是定时器，时钟错了，定时就错了，尴尬。F1的系统时钟初始化这部分，跟F4差别挺大的，可能不适用，大致参考一下。","tags":[{"name":"STM32","slug":"STM32","permalink":"https:/jungleeee.github.io.git/tags/STM32/"}]},{"title":"STM32(Cortex-M4) 定时器-DMA WS2812-GRB-LED","date":"2017-09-19T06:45:34.788Z","path":"2017/09/19/stm32-timer-dma/","text":"前言1学习、总结，交流，进步！ 测试环境为Keil 5.20 &amp;&amp; (STM32F405ZET6 || STM32F407ZET6)。采用来控制WS2812-GRB全彩LED，主要是因为其控制时序要求较高，频率快。如果使用中断的方式，处理时序容易出错。 原创，转载请注明出处。 关于WS28212说明WS2812实际可以认为有红、蓝、绿三个LED组成，通过控制其中的灯是否点亮以及点亮时的光照强度的不同组合，实现更多色彩的显示(三原色原理)。因此控制WS2812色彩显示的时候需要控制“三个LED”，总共包含24bit的控制数据，红、蓝、绿各8bit；由于8bit数据表示范围为0-255，所以光照强度可以分成256各等级。24bit数据格式如下图所示： 前面提到0-255表示该原色的亮度，因此就需要改变8bit数据每一位的0/1状态，其0码和1码的格式如下图所示： 从图中可以看到0码/1码是在固定周期中高低电平时间不同的组合。整个周期时长1.25us左右，允许误差600ns。虽然STM32指令周期很短了，但是使用中断方式的话，明显不是很好。 Timer-DMA请注意以下几点：1、关于STM32定时器色的DMA功能，需要注意的时TIM9-TMI14(100pin封装)是没有DMA功能的，所以在做硬件设计时需要注意。2、请注意定时器所挂载的时钟频率，保证定时器配置后输出频率正确：TIM2、3、4、5、6、7、12、13、14使用APB1时钟；TIM1、8、9使用APB2时钟。3、关于如何配置定时器输出PWM波，此处不介绍。 接下来开始程序搭建。我选择了TIM5-Channel2输出控制时序，TIM5的时钟挂载在APB1上面，所以打开該时钟，以及不要要忘记打开IO的映射功能。123RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM5, ENABLE); /* open tim5 clock *//* 其它此处不列出 */GPIO_PinAFConfig(GOIOA,GPIO_PinSource1,GPIO_AF_TIM5); /* GPIOA-pin1 AF tim5-channel2 */ 打开定时器时钟后，需要配置PWM的输出频率。上面介绍到WS2812每一位数据的周期是1.25us，也就是说需要设置PWM输出周期为1.25us。在我的STM32时钟配置中，APB1的时钟输出为84MHz，所以有以下配置：123TIM_TimeBaseInitStructure.TIM_Prescaler = 0; /* 1/84 = 0.0119047619047619us */TIM_TimeBaseInitStructure.TIM_Period = 105; /* 0.0119047619047619 * 105 = 1.254us //71 34 */TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up; 这里设置了定时器不分频，及其计数频率为(84 / (0+1))MHz，一次计数时间为0.01190476…us，所以继续配置计数重装载值为105，实现1.254us的PWM输出周期。那么可以继续得到，71和34两个数值分别表示高低电平的时长。PWM输出方式配置为小于捕获/比较寄存器的值时，输出高电平：123TIM_OCInitStructure.TIM_Pulse = 0;TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1;TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High; /* 小于TIM_Pluse的值时输出高电平 */ 输出连续的0/1的状态，也就是在定时器当前周期计数溢出开始下一个周期计数时，修改比较寄存器的值，改变输出高电平的时长，达到输出0/1的目的。也就是说需要在定时器计数溢出更新时触发DMA事件，通过DMA将新的比较寄存器的值写入到寄存器中。DMA配置如下：123456789101112DMA_InitStructure.DMA_Channel = DMA_Channel_6;DMA_InitStructure.DMA_PeripheralBaseAddr = (uint32_t)&amp;TIM5-&gt;CCR2; /* Peripheral address */DMA_InitStructure.DMA_Memory0BaseAddr = NULL; /* Memory address */DMA_InitStructure.DMA_DIR = DMA_DIR_MemoryToPeripheral; /* DMA dir Memory To Peripheral */DMA_InitStructure.DMA_BufferSize = 1; /* length */DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable; /* Peripheral address not add */DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable; /* Memory address add */DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Word; /* Peripheral data length */DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Word; /* Memory data length */DMA_InitStructure.DMA_Mode = DMA_Mode_Normal; /* normal mode */DMA_InitStructure.DMA_Priority = DMA_Priority_Medium; /* DMA Priority */DMA_Init(DMA1_Stream6, &amp;DMA_InitStructure); DMA数据长度初始化设置没有关系，在数据发送时设置即可。这里设置了外设数据字长为一个字(32bit)，需要注意一下。定时器2和定时器5的捕获/比较寄存器是32bit的，而其他是16bit的，如下图所示，更多请参考技术文档，希望大家注意。 关于DMA数据流和通道选择，请参考下图，更多信息请参考STM32技术文档。因为需要触发DMA的是溢出更新事件，所以选择的是TIM5_UP。 接下来选择DMA的触发源，打开定时器和DMA功能：123456789101112TIM_SelectCCDMA(TIM5, ENABLE); /* 配置为发生更新事件时产生DMA请求，详情请参考TIMx-CR2 寄存器 */TIM_DMACmd(TIM5, TIM_DMA_Update, ENABLE); /* 使能TIMx的更新DMA请求，详情请参考TIMx-DIER 寄存器 */TIM_UpdateRequestConfig(TIM5, TIM_UpdateSource_Regular); /* 使能URS位，只在定时器上溢/下溢时产生中断/DMA请求，详情请参考TIMx-CR1 寄存器 */TIM_UpdateDisableConfig(TIM5, DISABLE); /* 详情请参考TIMx-CR1 寄存器 */DMA_Cmd(DMA1_Stream6, ENABLE);DMA_ITConfig(DMA1_Stream6, DMA_IT_TC, DISABLE);DMA_ClearITPendingBit(DMA1_Stream6, DMA_IT_TCIF6);TIM_Cmd(TIM5, ENABLE);TIM_ITConfig(TIM5, TIM_IT_Update, DISABLE);TIM_ClearFlag(TIM5, TIM_FLAG_Update); 定时器的配置大致这样，有其他问题请参考其他。 ws2812 控制这里就简单说明以下。通过前面分析，知道了通过写入捕获比较寄存器的值(34/71)，实现0/1的位输出，所以定义：123456 |g7|g6|g5|g4|g3|g2|g1|g0|r7|r6|r5|r4|r3|r2|r1|r0|b7|b6|b5|b4|b3|b2|b1|b0|unsigned char green[] = &#123;71,71,71,71,71,71,71,71,34,34,34,34,34,34,34,34,34,34,34,34,34,34,34,34,0&#125;; /* 11111111 00000000 00000000 */unsigned char red[] = &#123;34,34,34,34,34,34,34,34,71,71,71,71,71,71,71,71,34,34,34,34,34,34,34,34,0&#125;;unsigned char blue[] = &#123;34,34,34,34,34,34,34,34,34,34,34,34,34,34,34,34,71,71,71,71,71,71,71,71,0&#125;;unsigned char white[] = &#123;71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,71,0&#125;;unsigned char reset[50] = &#123;0&#125;; /* 复位需要长达50us的低电平时间 */ 在实际控制中，只需要配置好需要的颜色，将数组的起始地址设置为DMA的内存地址后启动DMA即可。如果上一次操作完成后关闭了定时器，请记得打开。有一点需要注意以下，上面每个数组实际上都定义了25个成员，最后一个都为0。是因为DMA传输完成后，捕获/比较寄存器的值是最后一次传输的值，34/71，如果没有关闭定时器，那么定时器就会一直输出0码/1码(对于WS2812)，也就是WS2812的状态会变成全部熄灭(全0)/全亮(全1)，导致出错，所以DMA最后一次发送0到捕获/比较寄存器中，使得PWM输出一直为低。WS2812技术文档有说到输出低电平50us会复位，但在实际使用中发现，前一刻的状态并不会被改变，也就是说全输出为低电平时能够保持之前状态，经测试可行。上面提到了两种方式：1、传输完成后，在DMA传输完成中断函数中关闭定时器，下一次传输前打开定时器。！！！！！此方式未测试！！！！！！ 2、DMA传输最后一次数据到捕获/比较寄存器的值设置为0，通过输出低电平保持前一刻的状态。实测可行。 参考程序：https://github.com/jungleeee/Cortex-M/tree/master/Cortex-M4/timer-dma 结束语工作当中有这个LED的功能需求，在开发过程中还是遇到了一些问题，认认真真的看了TIMx-DMA着一块，还是有一些需要注意的东西。比如一开始选择DMA通道的时候，因为PWM输出时TIM5的通道2，就选择了DMA通道TIM5_CH2，实际应该是TIM5_UP，导致出错。还有一点是DMA发送完成后，传输完成位，会置位，如果配置了传输完成中断，可以在中断中清除此位，没有配置中断的话，必须在下一次发送前清除此位，否则下一次传输会失败。","tags":[{"name":"STM32","slug":"STM32","permalink":"https:/jungleeee.github.io.git/tags/STM32/"}]},{"title":"vim 常用插件配置","date":"2017-09-14T07:26:29.268Z","path":"2017/09/14/vim-plug-in/","text":"前言12学习、总结，交流，进步！插件与脚本使得VIM强大，毋庸置疑！ 全程参考: 所需及所获:像使用IDE一样vim其余参考将会在文中相关部分列出。文中内容如有错误，请指正！原创，转载请注明出处！ ReadyVIM的安转请自行进行。版本最好在7.5以上。请检查用户目录下是否存在: .vim/文件夹和.vimrc用户配置文件，可以使用命令 ls -l ~ 查看。.vim/文件夹用于存放后续所有插件。.vimrc用于配置VIM功能，包括基本语法、插件配置以及部分脚本等。如果没有请自行创建。 基本配置可以直接添加到.vimrc文件中: 123456789101112131415161718192021222324252627&quot; General set &quot; .vimrc 文件保存后自动生效 autocmd! bufwritepost .vimrc source % &quot; linux &quot;let g:mapleader=&quot;;&quot; &quot; vim 前缀键设置，默认为: \\ set autowrite &quot; auto save file set nobackup &quot; 不产生临时文件 set noswapfile &quot; 不产生临时文件 &quot;set t_ti= t_te= &quot; 退出VIM时，将当前屏幕内容显示到终端屏幕上 &quot; 不使用鼠标，方向键。实测插入模式中还是可以使用 &quot;set mouse-=a &quot;map &lt;Left&gt; &lt;Nop&gt; &quot;map &lt;Right&gt; &lt;Nop&gt; &quot;map &lt;Up&gt; &lt;Nop&gt; &quot;map &lt;Down&gt; &lt;Nop&gt; &quot; 普通模式时使用ctrl+h/j/k/l 实现多文件编辑时窗口切换 nnoremap &lt;C-j&gt; &lt;C-W&gt;j nnoremap &lt;C-k&gt; &lt;C-W&gt;k nnoremap &lt;C-h&gt; &lt;C-W&gt;h nnoremap &lt;C-l&gt; &lt;C-W&gt;l &quot; 插入模式时使用ctrl+h/j/k/l 实现光标移动 inoremap &lt;C-j&gt; &lt;Down&gt; inoremap &lt;C-k&gt; &lt;Up&gt; inoremap &lt;C-h&gt; &lt;Left&gt; inoremap &lt;C-l&gt; &lt;Right&gt; 插件管理Vundle是一个行之有效的插件，接管.vim/文件夹，为每一个插件指定唯一目录。更清晰、明了。Vundle会接管.vim/文件夹下的所有目录，所以先清空。在通过命令安装Vundle: 1git clone https://github.com/VundleVim/Vundle.vim.git ~/.vim/bundle/Vundle.vim 然后在.vimrc中增加配置: 123456789101112131415161718192021222324252627282930313233343536373839&quot; vundle set filetype off set rtp+=~/.vim/bundle/Vundle.vim call vundle#begin() Plugin &apos;VundleVim/Vundle.vim&apos; Plugin &apos;altercation/vim-colors-solarized&apos; Plugin &apos;tomasr/molokai&apos; &quot;Pluglin &apos;vim-scripts/phd&apos; &quot;Plugin &apos;Lokaltog/vim-powerline&apos; Plugin &apos;vim-airline/vim-airline&apos; Plugin &apos;vim-airline/vim-airline-themes&apos; &quot;Plugin &apos;nathanaelkane/vim-indent-guides&apos; Plugin &apos;Yggdroot/indentLine&apos; Plugin &apos;derekwyatt/vim-fswitch&apos; Plugin &apos;majutsushi/tagbar&apos; Plugin &apos;vim-scripts/indexer.tar.gz&apos; Plugin &apos;vim-scripts/DfrankUtil&apos; Plugin &apos;vim-scripts/vimprj&apos; Plugin &apos;easymotion/vim-easymotion&apos; &quot;Plugin &apos;mileszs/ack.vim&apos; Plugin &apos;dyng/ctrlsf.vim&apos; Plugin &apos;terryma/vim-multiple-cursors&apos; Plugin &apos;Yggdroot/LeaderF&apos; Plugin &apos;scrooloose/nerdcommenter&apos; Plugin &apos;ShowTrailingWhiteSpace&apos; Plugin &apos;SirVer/ultisnips&apos; &quot;Plugin &apos;honza/vim-snippets&apos; Plugin &apos;Valloric/YouCompleteMe&apos; Plugin &apos;scrooloose/nerdtree&apos; Plugin &apos;fholgado/minibufexpl.vim&apos; Plugin &apos;Tabular&apos; &quot; automatic alignment Plugin &apos;plasticboy/vim-markdown&apos; &quot; Plugin &apos;iamcco/markdown-preview.vim&apos; &quot;Plugin &apos;iamcco/mathjax-support-for-mkdp&apos; call vundle#end() filetype indent on &quot; different file smart indent filetype plugin on &quot; load the corrrsponding plug-in for different f filetype plugin indent on &quot; open antomatic completion vundle管理的插件必须位于call vundle#begin() 和 call vundle#end()之间，其中每项 1Plugin &apos;VundleVim/Vundle.vim&apos; 对应一个插件，后续如有新的插件，只需要追加到该列表中。安装新插件时需要在Github上找到插件地址，追加到列表中保存.vimrc文件，然后进入到VIM命令模式，执行: 1PluginInstall 便可以通过vundle自动安装插件。 需要卸载插件时，需要在.vimrc文件中注释该插件或者删除，保存.vimrc文件后，在命令模式执行: 1PluginClean 即可删除该插件。关于插件更新，直接在命令模式下，执行: 1PluginUpdate 即可更新整个插件列表。 关于插件: 多数插件在Github上都有不同的下载源，优先选取该插件的作者的下载源。 UI Theme界面优化，主题配置: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&quot; Vim-UI set &#123; &quot; theme &#123;很实用的两款:solarized、molokai set background=dark let g:solarized_termtrans=256 colorscheme solarized &quot;colorscheme molokai &quot;set guifont = &quot; set default font &quot; &#125; &quot; code fold &#123;代码折叠的方式，method: manual, indent, expr, syntax, diff, marker &quot;set foldenable &quot; 启动VIM时，折叠 set nofoldenable &quot; 启动VIM时，不折叠 set foldmethod=syntax &quot; 基于语法进行折叠 &quot;set foldmarker=&#123;,&#125; &quot; &#125; &quot; search &#123;搜索 set incsearch &quot; set hlsearch &quot; 搜索结果高亮 set ignorecase &quot; 忽略大小写 &quot; &#125; syntax enable &quot; 语法高亮 syntax on &quot; set expandtab &quot; 使用空格键代替TAB键 set tabstop=4 &quot; TAB键的宽度 set shiftwidth=4 &quot; TAB键4个空格键 &quot;set softtabstop=4 &quot; 把4个空格键自动识别为疑个TAB键 set laststatus=2 &quot; 总是显示状态栏 set ruler &quot; 打开状态标尺 set number &quot; 显示行号 set nowrap &quot; set autoindent &quot; 自动缩进 set cursorline &quot; 高亮当前行 &quot;set cursorcolumn &quot; 高亮当前列 set showmatch &quot; highlighting the matching brack &quot;set gcr=a:block-blinon0 &quot; 禁止光标闪烁 &quot;set guioptions-=l &quot; ban on the scroll bar dispaly &quot;set guioptions-=L &quot;set guioptions-=r &quot;set guioptions-=R &quot;set guioptions-=m &quot; ban on the menu bar dispaly &quot;set guioptions-=M&quot; &#125; 主题通过前面插件列表下载了solarized、molokai两款主题，可以通过注释其中一款而是用另一款。在实际使用中molokai可以直接使用，而主题solarized使用时，背景配色异常，最后通过以下方式正常使用（安装后能够正常使用的请忽略）。 选取终端菜单栏中Edit(编辑)栏，最后一项Profile Preference，在弹出界面框中选中color项，如下图所示: 代码折叠文件代码量大时，可能会对分析代码产生干扰，或者通过折叠函数调用与定义之间的代码，可以更加直观的理解函数功能。VIM自身支持多种折叠：手动折叠(manual)、基于缩进进行折叠(indent)、基于语义进行折叠(syntax)、未更改文本构成折叠等等。其中indent、syntax较为适合编程。此段摘抄 所需及所获:像使用IDE一样使用vim 4.3节。 操作: za: 打开或关闭当前折叠；zM: 关闭多有折叠；zR: 打开多有折叠。 其他VIM基本配置项很多，本人并没有进行太多设置，具体设置项的作用或者功能，请参考其他.vimrc文件，或者对该项Search，基本上都能够得到解释，在此不过多赘述。将会在文末贴上部分其他作者的.vimrc文件，以供参考。 插件详细状态栏12345set laststatus=2 &quot; 总是显示状态栏&quot;Plugin &apos;Lokaltog/vim-powerline&apos;Plugin &apos;vim-airline/vim-airline&apos;Plugin &apos;vim-airline/vim-airline-themes&apos; vim-powerline 和 vim-airline 都是状态栏美化插件，选用其一，注释另外一个。vim-airline-theme 提供 vim-airline 的主题，在其路径 vim-airline-theme/doc/ 下文件 airline-themes.txt 有对于可使用的主题的介绍。 状态栏配置，在.vimrc文件中添加以下内容: 12&quot; set powerline theme stylelet g:Powerline_colorscheme=&apos;solarized256&apos; 当选择vim-powerline作为状态栏主题时，添加上述内容；选择vim-airline时，添加以下内容: 12&quot; set airling theme stylelet g:airline_theme=&apos;powerlineish&apos; 可视化缩进12Plugin &apos;Yggdroot/indentLine&apos;&quot;Plugin &apos;nathanaelkane/vim-indent-guides&apos; 很多代码规范中建议代码嵌套最多不能超过3层，但难免有更多层出现。vim-indent-guides 插件提供可视化缩进，将相同缩进的代码关联起来，vim-indent-guides通过识别制表符来绘制缩进连接线。在.vimrc文件中添加如下配置: 1234&quot; set indent guideslet g:indent_guides_enable_on_vim_startup=1 &quot; 打开VIM时跟随启动let g:indent_guides_start_level=2 &quot; 从第二层开始可视化缩进let g:indent_guides_guide_sizw=1 &quot; 色块宽度 本人配置完成后使用，发现色块宽度占了4个空格，原因未查。 另外一个插件indentLine ，在显示可视化缩进时，只有一根细线，甚和我意。推荐一哈。后面还有一款他写的插件LeaderF，提供文件搜索功能，后面在介绍。indentLine基本上可以不用配置，但提供几个可选用配置项。 12345&quot; set indentLine&quot;let g:indentLine_enable = 1 &quot; 默认就是开启的&quot;let g:indentLine_char = &apos;┆&apos; &apos;│&apos; &apos;⎸&apos; &apos;▏&apos; &apos;¦&apos; &quot; 配置可视化缩进时的显示符号，选其一&quot;let g:indentLine_color_term = 239 &quot; 参看作者的解释&quot;map &lt;C-i&gt; :IndentLineToggle&lt;CR&gt; &quot; 映射快捷键用来开启/关闭可是话缩进 文件切换1Plugin &apos;derekwyatt/vim-fswitch&apos; vim-fswitch 用来实现在源文件和头文件中快速切换，但需要保证文件名相同，比如main.c和main.h。需要在.vimrc文件中添加: 12&quot; *.c** &amp; *.h, fast switchnmap &lt;M-t&gt; :FSHere&lt;CR&gt; &quot; 切换文件 *.c/cpp/.. &amp; *.h 我在这里使用了Alt+t组合键，M代表Alt键。除掉苹果键盘，Alt键就在大拇指下，个人觉得这个键，使用很方便。插播一下Alt键说明: 1我选择这个键只有一个原因，就是觉得的不用起来，好浪费。但是实际使用起来bug有比较多，所以。。。我选择了将就。 标签系统代码中的变量、宏、结构、枚举、类、函数、对象等等这些统称为标识符，每个标识符的定义、所在文件的行位置、所在文件的路径等信息就是标签（tag)。此段摘抄 所需及所获:像使用IDE一样使用vim 4.6节。 Exuberant Ctags就是一款经典的用于生成代码标签信息的工具，支持数十种语言。请在终端中执行命令安装。安装完成后，在代码目录中执行: 1ctags -R 将会在当前目录下生成tag文件，包含了当前目录下所有文件的标识符集合。 标签除了可以很直观展示当前文件中的各种信息，还能提供强大的导航和补全功能，接下来将会一一介绍。 在生成tag文件后，可以通过插件 tagbar 把从当前代码文件中提取出的所有标识符放在一个侧边子窗口中，并且能够按语法规则将标识符进行归类。tagbar安装完成后在.vimrc文件中添加如下配置: 123456789101112131415161718192021222324252627282930313233343536373839&quot; set tagbarmap &lt;F8&gt; :TagbarToggle&lt;CR&gt; &quot; 通过快捷键F8实现tagbar打开/关闭let tagbar_left=1 &quot; 设置tagbar子窗口的位置出现在主编辑的左边let tagbar_width=32 &quot; 设置窗口宽度let g:tagbar_compact=1 &quot; 子窗口不显示冗余帮助信息let g:tagbar_sort=0 &quot; 设置默认排序方式为在文中出现的位置let g:tagbar_type_cpp = &#123; &quot; 设置对哪些代码标识符生成标签 \\&apos;kinds&apos; : [ \\ &apos;c:classes:0:0&apos;, \\ &apos;d:macros:0:0&apos;, \\ &apos;e:enumerators:0:0&apos;, \\ &apos;f:functions:0:0&apos;, \\ &apos;g:enumeration:0:0&apos;, \\ &apos;l:local:0:0&apos;, \\ &apos;m:members:0:0&apos;, \\ &apos;n:namespaces:0:0&apos;, \\ &apos;p:functions_prototypes:0:0&apos;, \\ &apos;s:structs:0:0&apos;, \\ &apos;t:typedefs:0:0&apos;, \\ &apos;u:unions:0:0&apos;, \\ &apos;v:global:0:0&apos;, \\ &apos;x:wxternal:0:0&apos; \\ ], \\ &apos;sro&apos; : &apos;::&apos;, \\ &apos;kind2scope&apos; : &#123; \\ &apos;g&apos; : &apos;enum&apos;, \\ &apos;n&apos; : &apos;namespaces&apos;, \\ &apos;c&apos; : &apos;class&apos;, \\ &apos;s&apos; : &apos;struct&apos;, \\ &apos;u&apos; : &apos;union&apos; \\ &#125;, \\ &apos;scope2kind&apos; : &#123; \\ &apos;enum&apos; : &apos;g&apos;, \\ &apos;namespace&apos; : &apos;n&apos;, \\ &apos;class&apos; : &apos;c&apos;, \\ &apos;struct&apos; : &apos;s&apos;, \\ &apos;union&apos; : &apos;u&apos; \\ &#125; \\ &#125; 进入之前生成tag文件的目录下，打开某一源文件后，通过快捷键F8 打开tagbar子窗口，可以通过快捷键ctrl+w+w快速切换子窗口，类似alt+tab的功能，或者使用前面定义的ctrl+h/i/j/k在normal模式下进行窗口切换，进入到tagbar窗口中。 在标识符列表中选中对应标识符后即可跳转至源码中对应位置;在源码中停顿几秒，tagbar将高亮对应标识符。tagbar有两种排序方式，一是按标签字母先后顺序；一是按标签在源码中出现的先后顺序。此段摘抄 所需及所获:像使用IDE一样使用vim 4.7节。 注释掉let g:tagbar_sort=0，将会使用字母顺序排序。 开发时代码不停在变更，如果每次都需要手动执行命令生成新的标签文件，太麻烦。通过引入插件 indexer 实现自动生成标签。并引入。indexer 依赖 DfrankUtil、vimprj 两个插件，请一并安装。 此段摘抄所需及所获:像使用IDE一样使用vim 4.7节。 123Plugin &apos;vim-scripts/indexer.tar.gz&apos;Plugin &apos;vim-scripts/DfrankUtil&apos;Plugin &apos;vim-scripts/vimprj&apos; 并在.vimrc文件中添加: 1234&quot; 设置插件 indexer 调用 ctags 的参数&quot; 默认 --c++-kinds=+p+l，重新设置为 --c++-kinds=+p+l+x+c+d+e+f+g+m+n+s+t+u+v&quot; 默认 --fields=+iaS 不满足 YCM 要求，需改为 --fields=+iaSllet g:indexer_ctagsCommandLineOptions=&quot;--c++-kinds=+p+l+x+c+d+e+f+g+m+n+s+t+u+v --fields=+iaSl --extra=+q&quot; 另外，indexer 还有个自己的配置文件，用于设定各个工程的根目录路径，配置文件位于~/.indexer_files，内容格式为: 12[project_name]/project/code 方括号内为自动生成的标签文件名字，一般更工程一样。路径为工程的代码目录，不要包含构建目录，文档目录等，以免产生非代码文件的标签信息。当打开以上目录任何代码文件时，插件indexer便对整个目录创建标签文件，当代码有更新，文件保存时，indexer将自动调用ctags更新标签文件。indexer生成的标签文件以方括号内的名字命名，位于目录: ~/.indexer_files_tags/ 下，并自动引入Vim中。此处3段摘抄 所需及所获:像使用IDE一样使用vim 4.7节。 声明/定义跳转主要两类导航: 基于标签的跳转和基于语义的跳转。 既然Vim可以引入标签，说明Vim能识别标签。虽然标签文件中并无行号，但已经有标签所在文件以及标签所在行的完整内容，Vim只需切换至对应文件，再在文件内做内容查找即可找到对应行。换言之，只要有对应的标签文件，Vim就能根据标签跳转至标签定义处。 在前述已生成标签文件的项目目录中打开任意文件，将光标定位到某一函数名或变量上，键入快捷键g]，Vim将罗列处该函数或变量名所有的标签候选列表，按需要键入编号后按Enter键即可跳转进入。 基于语义的跳转是在后面介绍补全时的一款插件YCM的功能。此处直接给出快捷键设置，在.vimrc文件中添加配置: 123&quot;nnoremap &lt;M-=&gt; :YcmCompleter GoToDefinition&lt;CR&gt; &quot; jump to define&quot;nnoremap &lt;M-=&gt; :YcmCompleter GoToDeclaration&lt;CR&gt; &quot; jump to declarationnnoremap &lt;M-=&gt; :YcmCompleter GoToDefinitionElseDeclaration&lt;CR&gt; &quot; jump to define or declaration YCM提供这三个快捷键定义，意思很明了，可以根据自己情况进行配置，当然需要配置不同的快捷键。 但是个人感觉，这两个插件的跳转功能都不够好用。 写到这儿，有点不想写了。很多东西在我参考的文章中都很详细，很多地方都是摘抄过来的，所以后续我回直接贴出我所介绍的插件在原文章中的章节位置，然后主要介绍我所遇到的一些小问题和解决办法，以及我的快捷键配置，提供十分有限的参考价值，谢谢。 快速移动vim-easymotion 更多请参考 所需及所获:像使用IDE一样使用vim 8.3节。 .vimrc文件配置如下: 1Plugin &apos;easymotion/vim-easymotion&apos; 12&quot; set easymotionlet g:EasyMotion_leader_key=&apos;f&apos; 设置启用easymotion的前缀键&lt;Leader&gt;为f，在normal模式下，双击f键后输入需要跳转到的位置的字母，然后根据快速跳转的字符，快速定位到目标位置。 内容查找更多请参考 所需及所获:像使用IDE一样使用vim 4.8节。 ctrlsf.vim 后端调用ack一定记得安装。.vimrc文件中添加配置如下: 1Plugin &apos;dyng/ctrlsf.vim&apos; 123&quot; set ctrlsf let g:ctrlsf_ackprg=&apos;ack&apos; &quot; set default nnoremap &lt;M-f&gt; :CtrlSF&lt;CR&gt; &quot; 键入快捷键alt+f，搜索光标当前字符串的匹配项 ctrlsf通过p键可以定位到匹配项的完整代码，类似跳转功能，键入q退出插件。 内容替换更多请参考 所需及所获:像使用IDE一样使用vim 4.9节。 vim-multiple-cursors 配合ctrlsf插件，实现多个不同位置的字符串替换。.vimrc文件中添加如下配置: 1Plugin &apos;terryma/vim-multiple-cursors&apos; 123456&quot; set multiple-sursorslet g:multi_cursor_use_default_mapping=0let g:multi_cursor_next_key=&apos;&lt;S-n&gt;&apos;let g:multi_cursor_prev_key=&apos;&lt;S-p&gt;&apos;let g:multi_cursor_skip_key=&apos;&lt;S-s&gt;&apos;let g:multi_cursor_quit_key=&apos;&lt;ESC&gt;&apos; S表示Shift键。在通过ctrlsf插件列举处匹配项后，则可以通过快捷键S-n选中当前匹配项并跳到下一个匹配项，键入S-s则可以跳过当前项而选中下一个，可以通过S-p回退到前一个匹配项。键入Esc推出插件。 Vim自带很强大的替换功能，这里就不介绍了。建议了解一哈，一般会看这篇文档的，都有可能在面试的时候被提问。-_- 文件搜索1Plugin &apos;Yggdroot/LeaderF&apos; ctrlP 和LeaderF 插件都能实现文件搜索功能，ctrlP在网上搜索就能找到配置方法，这里不介绍。这里使用的LeaderF在网上资料不多，看作者的介绍操作，暂时还不够熟悉，后续补充。 快速注释更多请参考 所需及所获:像使用IDE一样使用vim 5.1节。 NERD Commenter 能够快速注释/取消注释，并且提供不同的注释方式。在.vimrc文件中添加配置: 1Plugin &apos;scrooloose/nerdcommenter&apos; 12345&quot; set nerdcommentermap &lt;M-c&gt; &lt;Leader&gt;cc &quot; add commentmap &lt;M-u&gt; &lt;Leader&gt;cu &quot; cancel commentmap &lt;M-a&gt; &lt;Leader&gt;ca &quot; switch /* */ &amp; //let g:NERDSpaceDelims=1 &quot; 强制在注释符旁边增加一个空格 在Vim normal模式下，键入v或者V进入可视化模式，通过h/j/k/l选中需要注释的部分，键入快捷键alt+c则注释当前选中代码。反之，选中需要取消注释的部分，键入快捷键alt+u取消注释。alt+a可以切换注释方式:/* */或者//，但这个快捷键定义跟某些有冲突，将就可用，也可以自定义其他。 行尾空格这个插件是我在知乎的一个回答中了解到的，有实用性，提供参考。贴上这个知乎的帖子:https://www.zhihu.com/question/19989337写程序时，虽然行尾的空格都看不见，遇上了的话，有点强迫症的肯定受不了。为了能够显示行尾的空格，需要ShowTrailingWhiteSpace这个插件。在.vimrc中添加如下内容: 1Plugin &apos;vim-scripts/ShowTrailingWhiteSpace&apos; 123&quot; set ShowTrailingWhitespacelet g:ShoeTrailingWhitespace=1 &quot; default ON; 1 on, 0 offhighlight ShowTrailingWhitespace ctermbg=Red guibg=Red &quot; 可以理解为高亮行尾空格 帖子中的回答者，还提供了一个快捷键，自动清理文件中所有行尾的空格: 12&quot;strip all trailing whitespace in the current filennoremap &lt;leader&gt;w :%s/\\s\\+$//&lt;cr&gt;:let @/=&apos;&apos;&lt;CR&gt; 我自己改变了一哈，每次保存文件(所有格式的文件)的时候，自动清除当前文件中所有行尾的空格: 12&quot;autocmd BufWritePre *.c,*.cpp,*.h,*.sh, :%s/\\s\\+$//eautocmd BufWritePre * :%s/\\s\\+$//e 注释掉的配置，表示只在这几个类型的文件执行保存文件命令时自动清除行尾空格，文件类型自己根据需要添加。 补全主要介绍三种补全:模板补全，基于标签的补全，基于语义的补全。 模板补全: 更多请参考 所需及所获:像使用IDE一样使用vim 5.2节。 ultisnips 提供相同代码段的快速输入，比如if-else、switch-case语句。在.vimrc文件中添加如下配置: 12Plugin &apos;SirVer/ultisnips&apos;&quot;Plugin &apos;honza/vim-snippets&apos; ultisnips补全时用于选中的键为tab，与后面将要提到的插件YCM的快捷键有冲突，所以提供改建的配置方式。个人选择改YCM的快捷键。 1234&quot; set ultisnips&quot;let g:UltiSnipsExpandTrigger=&quot;&lt;Leader&gt;&lt;tab&gt;&quot;&quot;let g:UltiSnipsJumpForwardTrigger=&quot;&lt;M-n&gt;&quot;&quot;let g:UltiSnipsJumpBackwardTrigger=&quot;&lt;M-m&gt;&quot; 另外需要说明的一点是，下载ultisnips插件后，默认是没有提供模板补全用的文件的。需要自己下载。一种方式时安装插件vim-snippets，复制~/.vim/bundle/vim-snippets/UltiSnips整个文件夹到~/.vim/bundle/ultisnips目录下面即可。另一种是自己到github上去下载， https://github.com/honza/vim-snippets ，其实内容都是一样的。我认为这个插件最好的点是支持自己定义，很强大。 基于标签的补全: 详情请参考 所需及所获:像使用IDE一样使用vim 5.3节部分。 基于语义的补全: 更多请参考 所需及所获:像使用IDE一样使用vim 5.3节部分。 YouCompleteMe 插件在安装过程中，参看文章的作者以及很多其他介绍YCM插件使用的作者都有说到，YCM原作者建议下载LLVM官网提供的预编译二进制文件，以避免各种问题。但我按照教程介绍，最后编译生成始终只有一个ycm_core.so文件，也没有查找到原因，待优化。然后后面我是按照YCM原作者Git项目中README.md文件中Ubuntu Linux x64部分实现安装的，不需要手动下载库，按作者的顺序执行即可，需要比较长的时间。需要确认已安装Cmake、python-dev、python3-dev，没有的话请自行安装。更多请自行阅读原作者 README.md 。 YCM插件需要在.vimrc文件中添加配置: 1Plugin &apos;Valloric/YouCompleteMe&apos; 123456789101112131415&quot; set YouCompleteset runtimepath+=~/.vim/bundle/YouCompleteMelet g:ycm_collect_identifiers_from_tags_files=1 &quot; 开启YCM标签补全let g:ycm_complete_in_comments=1 &quot; 补全功能在注释中同样有效let g:ycm_seed_identfiers_with_syntax=1 &quot; 语法关键字补全let g:ycm_confirm_extra_conf=0 &quot; 允许VIM加载.ycm_extra_conf.py 文件，不再提示let g:ycm_key_list_select_completion=[&apos;&lt;M-n&gt;&apos;, &quot;&lt;Down&gt;&quot;] &quot; 补全列表中 向下选中let g:ycm_key_list_previous_completion=[&apos;&lt;M-m&gt;&apos;, &quot;&lt;Up&gt;&quot;] &quot; 补全列表中 向上选中let g:ycm_min_num_of_chars_for_completion=2 &quot; 从第2个键入字符就开始罗列匹配项let g:ycm_cache_comnifunc=0 &quot; 禁止缓存匹配项，每次都重新生成匹配项&quot; 加载.ycm_extra_conf.py 文件的路径，可以不用每个工程目录下都去添加这个文件let g:ycm_global_ycm_extra_conf=&apos;~/.vim/bundle/YouCompleteMe/third_part/ycmd/cpp/ycm/.ycm_extra_conf.py&apos;&quot;nnoremap &lt;M-=&gt; :YcmCompleter GoToDefinition&lt;CR&gt; &quot; 跳转到声明/定义的位置，在前面跳转部分有介绍&quot;nnoremap &lt;c-j&gt; :YcmCompleter GoToDefinitionElseDeclaration&lt;CR&gt;nnoremap &lt;M-=&gt; :YcmCompleter GoToDefinitionElseDeclaration&lt;CR&gt; 另外还需要配置.ycm_extra_conf.py文件以及引入标签补全，这里就不做详述，请自行参考介绍。 工程文件管理NERDtree可以查看文件列表，要打开哪个文件，光标选中后回车即可在新buffer中打开。在.vimrc文件中添加如下配置: 1Plugin &apos;scrooloose/nerdtree&apos; 123456789&quot; set NERDTreenmap &lt;F9&gt; :NERDTreeToggle&lt;CR&gt;let NERDTreeShowBookmarks=1 &quot; set NERDTree book marks default onlet NERDTreeIgnore=[&apos;\\.py[cd]$&apos;, &apos;\\~$&apos;, &apos;\\.swo$&apos;, &apos;\\.swp$&apos;, &apos;^\\.git$&apos;, &apos;^\\hg$&apos;, &apos;^\\.svn$&apos;, &apos;\\.bzr$&apos;]let NERDTreeWinSize=32 &quot; set widthlet NERDTreeWinPos=&quot;right&quot; &quot; set positionlet NERDTreeShoeHidden=1 &quot; show the hidden fileslet NERDTreeMinimalUI=1 &quot; the window tags not show help infolet NERDTreeAutoDeleteBuffer=1 &quot; Automatically deletes files when deletes files buffer 更多请参考 所需及所获:像使用IDE一样使用vim 6.1节部分。 多文件编辑Vim中每打开一个文件Vim就对应创建一个buffer，多个文件就有多个buffer，但默认你只看得到最后buffer对应的Window，通过插件MiniBufExplorer可以切换到不同的buffer及达到编辑多个文件的功能。在.vimrc文件中添加配置: 1Plugin &apos;fholgado/minibufexpl.vim&apos; 12345&quot; set minibuffexploermap &lt;M-q&gt; :bn&lt;CR&gt; &quot; 切换多个buffer时的快捷键map &lt;M-w&gt; :bp&lt;CR&gt;&quot; 这个设置，网上我查到两种说法，一个是在gvim下时防止出现多窗口，一种是自动打开。实际情况看，无论是0/1，在只有一个文件时都会显示nimibufferlet g:let g:miniBufExplorerMoreThanOne=1 buffer快捷切换时，只需要在当前编辑文件中normal下按快捷键切换(需要存在多个buffer)，但是删除buffer时，需要将光标定位到buffer标签上。键入d删除光标所在buffer。 更多请参考 所需及所获:像使用IDE一样使用vim 6.2节部分。 自动对齐1Plugin &apos;godlygeek/tabular&apos; &quot; 自动对齐 后续补充。可自行搜索。 MarkdownMarkdown就不多解释了，在Vim编辑过程中最大的需求就是实时预览，在这里介绍插件markdown-preview，能够实现在浏览器中实时预览，默认是谷歌浏览器Chorme，自行下载。需要说明的是，这款插件在Github上比较多，比如markdown-preview，不需要浏览器支持即可实时预览，供君选择。vim-markdown 是一个语法高亮插件，根据实际情况使用。 在.vimrc文件中添加配置: 12Plugin &apos;plasticboy/vim-markdown&apos;Plugin &apos;iamcco/markdown-preview.vim&apos; 123456789&quot; set markdownlet g:mkdp_auto_start=0 &quot; set 1, the vim will auto open preview window once enter markdown bufferlet g:mkdp_auto_open=0 &quot; set 1, the vim will auto open preciew window when you edit the markdown filelet g:mkdp_auto_close=1 &quot; set 1, the vim will auto close current preview window when change from markdown buffer to another buflet g:mkdp_refresh_slow=0 &quot; set 1, the vim will just refresh markdown when save the buffer or leave frim insert mode,default 0 islet g:mkdp_command_for_global=0 &quot; set 1, the markdown preview command can be use for all files, by default it just can be use in markdolet g:mkdp_path_to_chrome=&quot;google-chrome&quot;map &lt;F6&gt; &lt;Plug&gt;MarkdownPreviewmap &lt;F7&gt; &lt;Plug&gt;StopMarkdownPreview 基本上都是默认配置，除了打开/关闭的快捷键映射。更多的话，可以自己到Github看作者介绍。 其他配置文件模板新建源文件时，一般都会添加一些文件信息在文件开始的位置处。常见比如文件名、作者、创建时间、文件简介等等，如果每次都手动添加，就会很麻烦。所以可以通过添加脚本函数的方式，实现文件新建时自动添加。在这里贴上一个.vimrc文件的配置，可以参考他的实现方式: https://github.com/taizilongxu/dotfiles/blob/master/vimrc 。文件中其他也可以参考。注意一点，如果需要判断是否为*.h文件，头文件，请使用if expand(&quot;%:e&quot;)==&#39;h&#39;进行判断。 自动添加时间需要的话也是通过脚本函数实现。.vimrc文件中添加配置: 123456789autocmd BufWritePre,FileWritePre *.c,*.h,*.sh,*.py ks|call LastChanged()|&apos;sfunc! LastChanged() &quot; auto add last changed date if line (&quot;$&quot;) &gt; 15 let l = 15 else let l = line(&quot;$&quot;) endif exe &quot;1,&quot;.l.&quot;g/Last Changed : /s/Last Changed : .*/Last Changed : &quot;.strftime(&quot;%c&quot;)endfunc 关于这一段的解释和详细介绍请参考: http://www.cnblogs.com/soli/archive/2009/10/21/885044.html 。 结束语第一次的环境配置就先这样了，后续有其他好用插件，会再推荐。文中还有没写完整的，会尽快补充。没有特别认真的写，比较水，希望不要介意，能够提供一丁点的帮助，我觉得也是好的。谢谢。 参考1、所需及所获:像使用IDE一样使用vim2、.vimrc3、.vimrc4、.vimrc5、vim配置技巧——在vim中使用autocmd命令在保存文件时自动插入最后修改日期和时间6、Vim与Markdown共舞7、NERD_commenter安装和使用","tags":[{"name":"VIM","slug":"VIM","permalink":"https:/jungleeee.github.io.git/tags/VIM/"}]}]